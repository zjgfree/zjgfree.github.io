<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>搜索与图论——DFS与BFS</title>
      <link href="/20231123/sou-suo-yu-tu-lun-dfs-yu-bfs/"/>
      <url>/20231123/sou-suo-yu-tu-lun-dfs-yu-bfs/</url>
      
        <content type="html"><![CDATA[<h1>DFS与BFS</h1><blockquote><p>由于这个博客是个人笔记性质的，且我接触DFS/BFS太多次了，就贴个代码算了</p></blockquote><h2 id="1-DFS（暴搜，广度优先算法）">1. DFS（暴搜，广度优先算法）</h2><ul class="lvl-0"><li class="lvl-2"><p>注意要防止爆栈，DFS空间复杂度高</p></li><li class="lvl-2"><p>优化剪枝</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int dfs(int u) {    if (...)return;//找到结果或者无路可走        st[u] = true; // st[u] 表示点u已经被遍历过    for (int i = h[u]; i != -1; i = ne[i]) {        int j = e[i];        if (!st[j]) dfs(j);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-BFS（深度优先算法）">2. BFS（深度优先算法）</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">queue<int> q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size()) {    int t = q.front();    q.pop();    for (int i = h[t]; i != -1; i = ne[i]) {        int j = e[i];        if (!st[j]) {            st[j] = true; // 表示点j已经被遍历过            q.push(j);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——Trie树</title>
      <link href="/20231123/shu-ju-jie-gou-trie-shu/"/>
      <url>/20231123/shu-ju-jie-gou-trie-shu/</url>
      
        <content type="html"><![CDATA[<h1><code>Trie</code>树（<strong>字典树</strong>、<strong>前缀树</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>）</h1><h2 id="1-数据结构">1.数据结构</h2><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20231101091828702.png" alt="image-20231101091828702" style="zoom: 50%;"><p><strong>结构特点</strong>：</p><ol><li class="lvl-3"><p><strong>根节点（root）不包含字符</strong>，除根节点外的每一个子节点都包含一个字符。</p></li><li class="lvl-3"><p>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p></li><li class="lvl-3"><p>每个节点都带一个**<u>标记</u>**，用于判断从根节点开始到该字符是否构成一个完整的单词。即当该字符标记为<code>true</code>，则该字符是某个单词的结尾。</p></li><li class="lvl-3"><p><strong>以空间换时间</strong>。利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。</p></li></ol><h2 id="2-算法模板与理解">2.算法模板与理解</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int son[N][26], cnt[N], idx;//son[父亲的位置][儿子的名字]=儿子的位置，26代表每个节点能延申出去26条边（26个字母）// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量，即cnt[]为标记// 插入一个字符串void insert(char *str) {    int p = 0;    for (int i = 0; str[i]; i ++ ) {        int u = str[i] - 'a';        if (!son[p][u]) son[p][u] = ++ idx;        p = son[p][u];    }    cnt[p] ++ ;}// 查询字符串出现的次数int query(char *str) {    int p = 0;    for (int i = 0; str[i]; i ++ ) {        int u = str[i] - 'a';        if (!son[p][u]) return 0;//如果没有u这个子节点        p = son[p][u];    }    return cnt[p];//返回这个字符串出现的次数}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——KMP</title>
      <link href="/20231123/shu-ju-jie-gou-kmp/"/>
      <url>/20231123/shu-ju-jie-gou-kmp/</url>
      
        <content type="html"><![CDATA[<h2 id="KMP算法">KMP算法</h2><p>KMP是一个说复杂也算复杂、说简单也的确简单的算法。网上的介绍和详解已经很多很好了(<a href="https://www.acwing.com/solution/content/14666/">AcWing 831. KMP字符串 - AcWing</a>)，这里只说一下自己的理解。<br><strong>核心思想</strong>：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找<code>next[ ]</code>数组确定的。</p><h2 id="1-自己的理解">1.自己的理解</h2><ol><li class="lvl-3"><p><strong>感觉这个算法最主要的地方就是构造next数组</strong>，当然这个<code>next</code>也有一种<code>go_back</code>数组的感觉在里面</p><p>这个算法最主要要解决的问题就是——字符串（也叫主串）中的模式（pattern）定位问题。也就是在一个字符串<code>string</code>中寻找关键字（符串）<code>pattern</code>，并求得其出现的具体位置。</p></li><li class="lvl-3"><p><code>i</code>表示一个字符串中的某一个位置，<code>j</code>表示一个<code>pattern</code>中的某一个位置，若<code>pattern</code>中的$[0, x]$和$[y,j]$是相同的一段（即<code>pattern</code>中的<u>末尾一段</u>和<u>从开头开始的某一段</u>相同），则当<code>string</code>中<u>从某个位置开始的到<code>i</code></u>能完全匹配<code>pattern</code>中的$[0, j]$，但<code>string[ i + 1 ]</code>与<code>pattern[ j + 1 ]</code>不匹配，则可尝试判断<code>string[i + 1]</code>与<code>pattern[ x + 1 ]</code>是否匹配</p></li></ol><h2 id="2-算法模板">2.算法模板</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">// s[]是长文本string，p[]是模式串pattern，n是s的长度，m是p的长度//序号从1开始//求模式串的Next数组：for (int i = 2, j = 0; i <= m; i ++ ){    while (j && p[i] != p[j + 1]) j = ne[j];    if (p[i] == p[j + 1]) j ++ ;    ne[i] = j;}// 匹配for (int i = 1, j = 0; i <= n; i ++ ){    while (j && s[i] != p[j + 1]) j = ne[j];    if (s[i] == p[j + 1]) j ++ ;    if (j == m) //满足匹配条件    {        // 匹配成功后的具体操作        printf("%d ", i - m + 1); //输出以1开始的匹配子串的首字母下标        j = ne[j];//再次从pattern中的某个点开始匹配    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——链表、队列、栈的数组模拟</title>
      <link href="/20231123/shu-ju-jie-gou-lian-biao-dui-lie-zhan-de-shu-zu-mo-ni/"/>
      <url>/20231123/shu-ju-jie-gou-lian-biao-dui-lie-zhan-de-shu-zu-mo-ni/</url>
      
        <content type="html"><![CDATA[<h1>链表、队列、栈的数组模拟</h1><blockquote><p>原文连接：<a href="https://www.acwing.com/blog/content/404/">常用代码模板2——数据结构 - AcWing</a></p></blockquote><h2 id="1-链表">1.链表</h2><h3 id="1-1单向链表">1.1单向链表</h3><h4 id="1-“数组模拟静态链表”的原因">1.“数组模拟静态链表”的原因</h4><ol><li class="lvl-3"><p>相较于通过定义结构体实现的单链表，不能实现随机存取，插入/去除任何一个元素都必须从指向表头的head指针出发</p></li><li class="lvl-3"><p><code>cpp</code>中<code>new()</code>内存动态分配函数执行速度较慢，相较于直接定义数组长度要慢得多</p></li></ol><h4 id="2-实现思路（空间换时间）">2.实现思路（空间换时间）</h4><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/%25E5%258D%2595%25E9%2593%25BE%25E8%25A1%25A8.png" alt="单链表" style="zoom:50%;"><p>在此基础上实现初始化、插入、删除等操作</p><h4 id="3-代码实现">3.代码实现</h4><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">const int N = 1e5 + 5;int val[N], nex[N], head, idx;//head存储链表头//val[]存储节点的值//nex[]存储节点的next指针//idx表示当前用到了哪个节点void init() {      head = -1;      //注意：这里的head并不是虚拟头节点，指向的就是链表的第一个节点，这样做主要是为了方便在头节点插入数据，最开始没有插入节点，head指向-1      idx = 0;        //还没插入节点，idx为0}void insertBeforeHead(int x) {      val[idx] = x;      //新插入一个值为x的节点      nex[idx] = head;   //x的下一个节点是原来的头节点，表示在头节点之前插入x      head = idx;        //head指针指向新节点      ++idx;             //更新插入节点的个数}//在第K个节点后插入一个节点void Insert(int k, int x) {      val[idx] = x;      nex[idx] = nex[k];      nex[k] = idx;      ++idx;}//删除指定节点，这里只用改变nex[]，不需要释放其空间void Delete(int k) {      nex[k] = nex[nex[k]];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-双向链表（仅代码实现）">2.双向链表（仅代码实现）</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init(){    //0是左端点，1是右端点    r[0] = 1, l[1] = 0;    idx = 2;}// 在节点a的右边插入一个数xvoid insert(int a, int x){    e[idx] = x;    l[idx] = a, r[idx] = r[a];    l[r[a]] = idx, r[a] = idx;    idx++;}// 删除节点avoid remove(int a){    l[r[a]] = l[a];    r[l[a]] = r[a];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-栈（仅代码实现）">2.栈（仅代码实现）</h2><h3 id="2-1普通实现">2.1普通实现</h3><h4 id="1-算法模板">1.算法模板</h4><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">// tt表示栈顶int stk[N], tt = 0;// 向栈顶插入一个数stk[ ++ tt] = x;// 从栈顶弹出一个数tt -- ;// 栈顶的值stk[tt];// 判断栈是否为空，如果 tt > 0，则表示不为空if (tt > 0){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-经典例题（用栈实现表达式求值）">2.经典例题（用栈实现表达式求值）</h4><ul class="lvl-0"><li class="lvl-2"><p>原题链接：<a href="https://www.acwing.com/problem/content/3305/">3302. 表达式求值 - AcWing题库</a></p></li><li class="lvl-2"><p>本人代码实现：</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>#include <vector>using namespace std;#define not_exist 9#define ERROR -1const int N = 1E5 + 10;vector<int> num;vector<char> sign;//判断各符号之间的优先级，1表示优先，0表示同级，-1表示低一级，not_exist表示情况不存在int priority[6][6] = {//第一个空是一个序列中从左到右的前一个符号，第二个空是后一个符号    /*    1是push_back    0是pop_back    -1是cal    */    {1, 0, 1, 1, 1, 1},//相对于（    {1, 1, 1, 1, 1, 1},//相对于）    {1, -1, -1, -1, 1, 1},//相对于+    {1, -1, -1, -1, 1, 1},//相对于-    {1, -1, -1, -1, -1, -1},//相对于*    {1, -1, -1, -1, -1, -1},//相对于/};//识别一个运算符并定位到数组int ident_sign (char sign) {    switch (sign) {        case '(':            return 0;            break;        case ')':            return 1;            break;        case '+':            return 2;            break;        case '-':            return 3;            break;        case '*':            return 4;            break;        case '/':            return 5;            break;        default:            return ERROR;             break;    };}//将str中的字符串读入到数字栈和运算符栈中,边度边算int read_str_and_cal (string str) {    str.append(1,'+');//因为每次计算都是以符号为信号，所以最后有一步首尾工作    //str.push_back('+');    //str += '+';    for (int t = 0 ; t<str.size() ; t++) {//t为str下标        if ( isdigit(str[t]) ) {//从str读取到一个数字            if ( isdigit(str[t-1]) ) {//如果上一位也是数字                int a = num.back();                num.pop_back();                num.push_back(  a*10 + str[t] - '0' );            }            else    num.push_back(str[t] - '0');        }        else {//每次读取到一个符号就进行判断是否计算loop:            if ( !sign.empty() ) {//如果符号栈不为空                char c2 = str[t], c1 = sign.back();                int i2 = ident_sign(c2), i1 = ident_sign(c1);                int pri = priority[i1][i2];//返回优先级比较结果                switch (pri) {                    case 1://更优先                        sign.push_back(c2);                        break;                    case 0://括号匹配，消除左括号                        sign.pop_back();                        break;                    case -1: //执行计算                        if (num.size() > 1) {                            int num2 = num.back();  num.pop_back();                            int num1 = num.back();  num.pop_back();                            sign.pop_back();                            switch (c1) {//计算并压入num栈                                case '+':                                    num.push_back(num1 + num2);                                    break;                                case '-':                                    num.push_back(num1 - num2);                                    break;                                case '*':                                    num.push_back(num1 * num2);                                    break;                                case '/':                                    num.push_back(num1 / num2);                                    break;                                default:                                    cout << "cal ERROR\n\n";                                    break;                            }                        }                        goto loop;                        break;                    default:                        printf("priority ERROR\n\n");                        break;                }            }            else sign.push_back(str[t]);        }    }    return num[0];}int main () {    string str;    cin >> str;    int ans = read_str_and_cal(str);    cout << ans << endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2单调栈">2.2单调栈</h3><h4 id="1-算法模板-2">1.算法模板</h4><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">常见模型：找出每个数左边离它最近的比它大/小的数int tt = 0;for (int i = 1; i <= n; i ++ ){    while (tt && check(stk[tt], i)) tt -- ;    stk[ ++ tt] = i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-经典例题（某个数左边最近比它小的数）">2.经典例题（某个数左边最近比它小的数）</h4><p>最开始<code>AcWing</code>上面单调栈的题因为没有看懂模板要干啥，所有用自己的想法写了一遍。虽然感觉也还算巧妙但确实比题解上面的写法差远了。这里附上<u>原题</u>、<u>我的解法</u>和<u>题解</u>解法帮助理解</p><ul class="lvl-0"><li class="lvl-2"><p>原题题目</p></li></ul><blockquote><p>给定一个长度为 <code>N</code> 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 <code>−1</code>。</p><h4 id="输入格式">输入格式</h4><p>第一行包含整数 <code>N</code>，表示数列长度。第二行包含<code>N</code>个整数，表示整数数列。</p><h4 id="输出格式">输出格式</h4><p>共一行，包含 <code>N</code> 个整数，其中第 <code>i</code> 个数表示第 <code>i</code> 个数的左边第一个比它小的数，如果不存在则输出 <code>−1</code>。</p><h4 id="数据范围">数据范围</h4><p>$$<br>1\le N \le 10^5 \<br>1\le 数列中的元素 \le 10^9<br>$$</p><h4 id="输入样例：">输入样例：</h4><pre class="line-numbers language-language-markdown"><code class="language-language-markdown">53 4 2 7 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例：">输出样例：</h4><pre class="line-numbers language-language-markdown"><code class="language-language-markdown">-1 3 -1 2 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><ul class="lvl-0"><li class="lvl-2"><p>自己的解法</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>using namespace std;const int N = 1e5 + 10;int stack[N];//存放输入的数据int t = 0;//指向栈顶的“指针”struct record {    int value;    int site;}min_l[N];//存放对于每一个点左边第一个比它小的数的“大小”和“坐标”int main() {    int n;      cin >> n;    //输入    for (int i = 0 ; i < n ; i ++ ) {        int x;      cin >> x;        stack[++t] = x;    }    //min_1[1]    min_l[1].value = -1;    min_l[1].site = -1;//site为-1表示该点不存在    cout << min_l[1].value << ' ';    for (int i = 2 ; i <= t ; i++) {        int k = i-1;        while (stack[k] >= stack[i]) {//出现左边的点比当前点要大            if (min_l[k].value >= stack[i])//不符合小于当前点i的条件，坐标跳转                k = min_l[k].site;            else    {                min_l[i].value = min_l[k].value;                min_l[i].site = min_l[k].site;                break;            }        }        if (stack[k] < stack[i]) {//出现左边的点比当前点要小            min_l[i].value = stack[k];            min_l[i].site = k;        }        cout << min_l[i].value << ' ';    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>使用“单调栈”算法模板的解法</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>using namespace std;const int N = 100010;int stk[N], tt;int main(){    int n;    cin >> n;    while (n -- )    {        int x;        scanf("%d", &x);        while (tt && stk[tt] >= x) tt -- ;//如果栈顶元素大于当前待入栈元素，则出栈        if (!tt) printf("-1 ");//如果栈空，则没有比该元素小的值。        else printf("%d ", stk[tt]);//栈顶元素就是左侧第一个比它小的元素。        stk[ ++ tt] = x;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-队列（仅代码实现）">3.队列（仅代码实现）</h2><h3 id="3-1普通队列">3.1普通队列</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">// hh 表示队头，tt表示队尾int q[N], hh = 0, tt = -1;// 向队尾插入一个数q[ ++ tt] = x;// 从队头弹出一个数hh ++ ;// 队头的值q[hh];// 判断队列是否为空，如果 hh <= tt，则表示不为空if (hh <= tt){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2循环队列">3.2循环队列</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">// hh 表示队头，tt表示队尾的后一个位置int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空，如果hh != tt，则表示不为空if (hh != tt){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3单调队列">3.3单调队列</h3><h4 id="1-算法模板-3">1.算法模板</h4><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">常见模型：找出滑动窗口中的最大值/最小值int hh = 0, tt = -1;for (int i = 0; i < n; i ++ ){    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口    while (hh <= tt && check(q[tt], i)) tt -- ;    q[ ++ tt] = i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-经典例题（滑动窗口）">2.经典例题（滑动窗口）</h4><p>这个单调队列<code>AcWing</code>上面讲的老实讲，没看懂。参考了知乎上的一篇文章：<a href="https://zhuanlan.zhihu.com/p/346354943">算法学习笔记(66): 单调队列 - 知乎 (zhihu.com)</a>，个人觉得写的还不错！比喻还算比较清晰。下面附上原题和相关代码。</p><ul class="lvl-0"><li class="lvl-2"><p>原题链接：<a href="https://www.acwing.com/problem/content/156/">154. 滑动窗口 - AcWing题库</a></p></li><li class="lvl-2"><p>个人代码</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>#include <deque>//双向队列using namespace std;const int N = 1e6 + 10;int queue[N] = {0};deque<int> max_deque, min_deque;//双向队列中存储的是某个值在输入数据中对应的位置int main() {    int n,k;    cin >> n >> k;    int total_win = n - ( k-1 );    int max_k[total_win] = {0}, min_k[total_win] = {0};//存储滑动窗口的最大最小值    //输入数据    for (int i = 0 ; i < n ; i++ )  cin >> queue[i];    //初始化双向队列max_deque, min_deque;   求出第一个滑动窗口(序号为0)的max与min    max_deque.push_back(0);    for (int i = 1 ; i < k ; i ++ ) {//此时i表示是第几个数据        while (max_deque.size() > k-1)    max_deque.pop_front();//必须给新的元素留空        while (!max_deque.empty() and queue[max_deque.back()] <= queue[i])   max_deque.pop_back();        max_deque.push_back(i);    }    max_k[0] = max_deque.front();    min_deque.push_back(0);    for (int i = 1 ; i < k ; i ++ ) {        while (min_deque.size() > k-1)    min_deque.pop_front();//必须给新的元素留空        while (!min_deque.empty() and queue[min_deque.back()] >= queue[i])   min_deque.pop_back();        min_deque.push_back(i);    }    min_k[0] = min_deque.front();    //从第二个滑动窗口开始，对( n - ( k-1 ) )个窗口进行计算维护    for (int i = 1 ; i < total_win ; i++) {//此时i表示是第几个滑动窗口        //维护最大值        while (!max_deque.empty() and max_deque.front() < i)   max_deque.pop_front();//保证队首元素位置在当前窗口内        while (max_deque.size() > k-1)    max_deque.pop_front();//必须给新的元素留空        while (!max_deque.empty() and queue[max_deque.back()] <= queue[k-1 + i]) max_deque.pop_back();//维护队尾元素        max_deque.push_back( k-1 + i );        max_k[i] = max_deque.front();        //维护最小值        while (!min_deque.empty() and min_deque.front() < i)   min_deque.pop_front();//保证队首元素位置在当前窗口内        while (min_deque.size() > k-1)    min_deque.pop_front();//必须给新的元素留空        while (!min_deque.empty() and queue[min_deque.back()] >= queue[k-1 + i])   min_deque.pop_back();//维护队尾元素        min_deque.push_back( k-1 + i );        min_k[i] = min_deque.front();    }    //输出    for (int i = 0 ; i < total_win ; i++)   cout << queue[min_k[i]] << ' ';    cout << endl;    for (int i = 0 ; i < total_win ; i++)   cout << queue[max_k[i]] << ' ';        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>题解代码</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>#include <cstring>#include <algorithm>#include <deque>using namespace std;const int N = 1000010;int a[N];int main(){    int n, k;    cin >> n >> k;    for (int i = 1; i <= n; i ++ ) cin >> a[i];//读入数据    deque<int> q;    for(int i = 1; i <= n; i++)    {        while(q.size() && q.back() > a[i]) //新进入窗口的值小于队尾元素，则队尾出队列            q.pop_back();        q.push_back(a[i]);//将新进入的元素入队        if(i - k >= 1 && q.front() == a[i - k])//若队头是否滑出了窗口，队头出队             q.pop_front();        if(i >= k)//当窗口形成，输出队头对应的值            cout << q.front() <<" ";    }    q.clear();    cout << endl;    //最大值亦然    for(int i = 1; i <= n; i++)    {        while(q.size() && q.back() < a[i]) q.pop_back();        q.push_back(a[i]);        if(i - k >= 1 && a[i - k] == q.front()) q.pop_front();         if(i >= k) cout << q.front() << " ";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——哈希表</title>
      <link href="/20231123/shu-ju-jie-gou-ha-xi-biao/"/>
      <url>/20231123/shu-ju-jie-gou-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h1>哈希表（散列表）</h1><p>因为Hash理解起来比较简单，所以直接上代码，就不过多废话了。</p><blockquote><p>参考知乎文章：<a href="https://zhuanlan.zhihu.com/p/144296454">图文并茂详解数据结构之哈希表 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="1-数据结构特点">1. 数据结构特点</h2><ol><li class="lvl-3"><p><strong>快速插入</strong>和<strong>快速查找</strong>，时间复杂度为<code>O(1)</code></p></li><li class="lvl-3"><p>哈希表被填满后，涉及到扩容操作，效率低下</p></li><li class="lvl-3"><p>哈希值有<strong>碰撞（冲突）<strong>概率，解决碰撞的两种方式——<strong>开放寻址法</strong>与</strong>拉链法</strong></p></li></ol><h2 id="2-开放寻址法（以线性探测为例）">2. 开放寻址法（以线性探测为例）</h2><ul class="lvl-0"><li class="lvl-2"><p>三种方式：</p><ol><li class="lvl-5">线性探测</li><li class="lvl-5">二次探测</li><li class="lvl-5">再哈希法</li></ol></li></ul><h3 id="2-1-解释说明">2.1 解释说明</h3><p><strong>线性探测</strong>就是原始值经过一系列Hash函数后映射到Hash表中，若当前值已经被某一个数据所占有，则在当前位置的后一位置存储，若后一位置也已经被某一个数据所占有，则<strong>依次往后</strong>直到找到一个空位置</p><blockquote><p>在算法竞赛中，我们常常需要用到设置一个常量用来代表“无穷大”。</p><p>比如对于<code>int</code>类型的数，有的人会采用<code>INT_MAX</code>，即<code>0x7fffffff</code>作为无穷大。但是以<code>INT_MAX</code>为无穷大常常面临一个问题，即加一个其他的数会溢出。而这种情况在动态规划，或者其他一些递推的算法中常常出现，很有可能导致算法出问题。</p><p>所以在算法竞赛中，我们常采用<code>0x3f3f3f3f</code>来作为无穷大。<code>0x3f3f3f3f</code>主要有如下好处：<code>0x3f3f3f3f</code>的十进制为<code>1061109567</code>，和<code>INT_MAX</code>一个数量级，即<code>10^9</code>数量级，而一般场合下的数据都是小于<code>10^9</code>的。<code>0x3f3f3f3f * 2 = 2122219134</code>，无穷大相加依然不会溢出。</p><p>可以使用<code>memset(array, 0x3f, sizeof(array))</code>来为数组设初值为<code>0x3f3f3f3f</code>，因为这个数的每个字节都是0x3f。</p><p>来源：<a href="https://www.acwing.com/file_system/file/content/whole/index/content/4799/">https://www.acwing.com/file_system/file/content/whole/index/content/4799/</a></p></blockquote><h3 id="2-2-代码实现">2.2 代码实现</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int h[N];memset(h, 0x3f, sizeof h);//h[N]使用需要初始化为每一项均为0x3f3f3f3f// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置int find(int x) {    int t = (x % N + N) % N;//(x % N + N) % N作用：保证t是正值    while (h[t] != null && h[t] != x) {        t ++ ;        if (t == N) t = 0;    }    return t;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-拉链法">3. 拉链法</h2><h3 id="3-1-图解">3.1 图解</h3><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20231122193532209.png" alt="image-20231122193532209" style="zoom: 80%;"><h3 id="3-2-代码实现">3.2 代码实现</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int h[N], e[N], ne[N], idx;/*e[idx]存储的是索引为idx的原始值xne[idx]存储的是（原始值为x，Hash值为k）拉链中索引为idx的拉链块儿所连接的下一个拉链块儿（数组模拟链表）h[k]存储的是（原始值为x，Hash值为k）块儿中最新插入的数据对应的索引idx存储的是索引，每插入一个数，idx++*/// 向哈希表中插入一个数void insert(int x) {    int k = (x % N + N) % N;    e[idx] = x;    ne[idx] = h[k];//ne[idx]指向原h[k]指向的第一个拉链块儿对应的idx    h[k] = idx ++ ;//h[k]指向新的第一个拉链块儿的索引idx;}// 在哈希表中查询某个数是否存在bool find(int x) {    int k = (x % N + N) % N;    for (int i = h[k]; i != -1; i = ne[i])        if (e[i] == x)            return true;    return false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-字符串哈希">4. 字符串哈希</h2><blockquote><p>字符串哈希学习文章推荐：<a href="https://blog.csdn.net/Mikchy/article/details/103995537">【算法学习】字符串哈希（Hash）_字符串hash-CSDN博客</a></p><ul class="lvl-1"><li class="lvl-2">自然溢出Hash</li></ul><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20231122203413522.png" alt="image-20231122203413522"></p><p>所以计算字<strong>符串前k个字母的哈希值</strong>的公示为：</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20231122203610391.png" alt="image-20231122203610391"></p><p><strong>求子字符串的公示</strong>为：</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20231122203724640.png" alt="image-20231122203724640"></p><p>例如，对于求**子字符串$s_3s_4$**的值，公示如下：</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20231122203839869.png" alt="image-20231122203839869"></p></blockquote><p>Hash在算法里面运用的比较简单，所以不过多解释，直接上$yxc$的代码模板</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">/*核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果*/typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k(P的K次方) mod 2^64// 初始化p[0] = 1;for (int i = 1; i <= n; i ++ ) {    h[i] = h[i - 1] * P + str[i];    p[i] = p[i - 1] * P;}// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r) {    return h[r] - h[l - 1] * p[r - l + 1];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——堆</title>
      <link href="/20231123/shu-ju-jie-gou-dui/"/>
      <url>/20231123/shu-ju-jie-gou-dui/</url>
      
        <content type="html"><![CDATA[<h1>堆</h1><h2 id="1-数据结构">1.数据结构</h2><blockquote><p>堆的定义如下：<code>n</code>个元素的序列<code>{k1,k2,ki,…,kn}</code>当且仅当满足下关系时，称之为堆。<br>$$<br>(k_i \le k_{2i} 且 k_i \le k_{2i+1})或者(k_i \ge k_{2i} 且 k_i \ge k_{2i+1}),(i = [1,\frac{n}{2}])<br>$$</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>最高效的<strong>优先级队列</strong>。可以被看作一棵<strong>完全二叉树</strong>（<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树_百度百科 (baidu.com)</a>）的数组对象。</p></li><li class="lvl-2"><p>堆中某个结点的值总是不大于或不小于其父结点的值。</p></li><li class="lvl-2"><p>根结点最大的堆叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根结点最小的堆叫做<strong>最小堆</strong>或<strong>小根堆</strong>。常见的堆有<strong>二叉堆</strong>、<strong>斐波那契堆</strong>等。</p></li><li class="lvl-2"><p>堆是非线性数据结构，相当于一维数组，有两个直接后继。<mark>堆通常用一维数组存储</mark>。假设某个节点（根节点除外）对应的一维数组下标为<code>x</code>(一维数组下标从1开始），<strong>则其父节点下标为<code>x/2</code>，左子节点下标为<code>2x</code>，右子节点下标为<code>2x+1</code></strong>。</p></li><li class="lvl-2"><p>用数组实现堆时，<strong>堆为完全二叉树而不是非完全二叉树的本质是因为其数组的存储结构</strong>。</p></li></ul><p>图解：</p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/%25E5%25B0%258F%25E6%25A0%25B9%25E5%25A0%2586%25E5%259B%25BE%25E8%25A7%25A3.jpg" alt="小根堆图解" style="zoom:67%;"><h2 id="2-相关操作原理（以小根堆为例）">2.相关操作原理（以小根堆为例）</h2><p><strong>始终记住堆是一个<u>完全二叉树</u>且满足<u>一个节点和其父节点两个子节点需满足的大小关系</u>！</strong></p><h3 id="2-1堆的插入">2.1堆的插入</h3><p>当一个新元素想要插入这个堆的时候，我们首先把他放到这个堆的末尾<mark>（<u>放到末尾可以满足完全二叉树的特性</u>）</mark>。然后依据堆的特性，对它的位置进行调整（不断上浮），直至满足堆的条件。</p><h3 id="2-2堆中元素的删除">2.2堆中元素的删除</h3><p>一般是删除堆顶元素，将数组末尾的元素拿到堆顶空缺的位置，然后对其进行下沉操作。若要求删除非堆顶元素，则将该元素（1）首先和堆顶元素（2）进行置换，再删除（2），将堆尾元素（3）补充到堆顶，然后堆元素（1）和元素（3）进行位置调整。</p><h3 id="2-3小根堆的建立">2.3小根堆的建立</h3><p>堆的建立即为“堆的插入”的应用。将元素不断放到堆的末尾，然后进行位置调整。</p><h2 id="3-代码实现（以小根堆为例）">3.代码实现（以小根堆为例）</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;void heap_swap(int a, int b) {// 交换两个点，及其映射关系    swap(ph[hp[a]],ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);}void down(int u) {//把一个节点不断 下沉 使其存储在合适位置    int t = u;    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;//h[u]比其左儿子小,t为其左儿子    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;//若右儿子比左儿子小,则t为其右儿子    if (u != t) {        heap_swap(u, t);        down(t);    }}void up(int u) {//把一个节点不断 上浮 使其存储在合适位置    while (u / 2 && h[u] < h[u / 2]) {        heap_swap(u, u / 2);        u >>= 1;//u除以2的快速实现    }}// O(n)建堆for (int i = n / 2; i; i -- ) down(i);//从最后一个节点的父节点开始，i--从后往前对所有节点进行下沉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-对建堆代码for-int-i-n-2-i-i-down-i-的思考">4.对建堆代码<code>for (int i = n / 2; i; i -- ) down(i);</code>的思考</h2><ol><li class="lvl-3"><p>该代码的意义和形象理解是什么？</p><ul class="lvl-2"><li class="lvl-5">从最后一个有儿子节点的父节点向前遍历，依次让每个结点找到其合适的位置</li></ul></li><li class="lvl-3"><p>除了这种建堆方式，还有什么别的建堆方式？</p><ul class="lvl-2"><li class="lvl-5">①从最后一个非叶子节点开始，逐个向前进行下沉操作来实现</li><li class="lvl-5">②从第一个非叶子节点开始，逐个向后进行上浮操作来实现</li></ul></li><li class="lvl-3"><p>为什么<code>down()</code>操作必须满足左右子树均为堆？</p><ul class="lvl-2"><li class="lvl-5">如果一个节点的左右子树不满足堆的性质，那么下沉操作可能导致破坏堆的性质</li></ul></li><li class="lvl-3"><p>为什么要从<code>i = n / 2</code>往上建堆？</p><ul class="lvl-2"><li class="lvl-5">只需要对索引小于等于 <code>n / 2</code> 的节点进行下沉操作，即从最后一个非叶子节点开始（最后一个有儿子节点的父节点），逐个向前处理每个非叶子节点，直到根节点。</li></ul></li><li class="lvl-3"><p>为什么不从 <code>i = 1 开始到 i == n</code>，将每一个节点挨个插入的方式建堆？</p><ul class="lvl-2"><li class="lvl-5"><p>如果采用从 <code>i = 1</code> 开始到 <code>i == n</code> 的方式，将每个节点逐个插入堆中，那么建堆的时间复杂度将变为 <code>O(nlogn)</code>，而不是 <code>O(n)</code>。</p><p>因为插入操作的时间复杂度是 <code>O(logn)</code>。当我们将一个元素插入到堆中时，需要将其放置在堆的末尾，然后进行上浮操作，将其与父节点进行比较和交换，直到满足堆的性质。在最坏情况下，新插入的元素需要上浮到堆的根节点位置，这需要进行 <code>O(logn)</code> 次比较和交换操作。</p><p>如果我们按顺序逐个插入所有的节点，则第一个插入的节点需要进行 <code>O(logn)</code> 次操作，第二个插入的节点需要进行 <code>O(logn-1)</code> 次操作，以此类推。总的时间复杂度为：<code>O(logn) + O(logn-1) + O(logn-2) + ... + O(1) = O(logn + log(n-1) + log(n-2) + ... + log(1))</code>，个和式的结果是 <code>O(logn!)</code>，即 <code>O(nlogn)</code>。</p><p>相比之下，从 <code>i = n / 2</code> 开始进行下沉操作的方式可以在 <code>O(n)</code> 的时间内建立堆。</p></li></ul></li><li class="lvl-3"><p>为什么不直接使用<code>sort()</code>操作建堆（令<code>sort()</code>操作满足数组元素从小到大排列或从大到小排列，对存储堆元素的数组直接排序）？</p><ul class="lvl-2"><li class="lvl-5"><code>sort()</code> 函数通常使用的是比较排序算法，例如快速排序、归并排序、堆排序等。这些排序算法的时间复杂度通常为<code>O(nlogn)</code>，大于该操作的时间复杂度<code>O(n)</code>；</li><li class="lvl-5"><code>sort()</code>操作满足从小到大排列或从大到小排列后，生成的结果是完全单调的。而堆并不需要满足完全单调的性质，只需要确保父节点和子节点的相对大小关系即可。</li></ul></li><li class="lvl-3"><p>该操作（<code>for (int i = n / 2; i; i -- ) down(i);</code>）建堆的时间复杂度为什么是<code>o(n)</code>的？</p><ul class="lvl-2"><li class="lvl-5"><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/%25E5%25BB%25BA%25E5%25A0%2586%25E6%2597%25B6%25E9%2597%25B4%25E5%25A4%258D%25E6%259D%2582%25E5%25BA%25A6%25E4%25B8%25BAO(n)%25E7%259A%2584%25E8%25AF%2581%25E6%2598%258E.jpg" alt="建堆时间复杂度为O(n)的证明" style="zoom: 67%;"></li></ul></li><li class="lvl-3"><p>该操作直接满足了节点与其子节点之间的相对大小关系，而不是整个数组都是从小到大排序的，那堆排序是如何实现的？</p><ul class="lvl-2"><li class="lvl-5"><p>（转自<code>Chat-GPT 3.5</code>）</p><p>堆排序是一种基于堆数据结构的排序算法。它的主要思想是将待排序的数组构建为一个最大堆（或最小堆），然后不断地取出堆顶元素，将其与堆的最后一个元素交换，再对剩余的元素进行堆调整，重复这个过程直到整个数组有序。</p><p>下面是堆排序的步骤：</p><ol><li class="lvl-8"><p>建堆：将待排序的数组构建为一个最大堆（或最小堆），这可以通过<strong>从最后一个非叶子节点开始，逐个向前进行下沉操作来实现</strong>。或者，也可以<strong>从第一个非叶子节点开始，逐个向后进行上浮操作来实现</strong>。</p></li><li class="lvl-8"><p>排序：将堆顶元素与堆的最后一个元素交换，即将最大（或最小）元素放到数组的末尾。然后，对剩余的元素进行堆调整，以维护堆的性质。</p></li><li class="lvl-8"><p>重复步骤 2，直到整个数组有序。每次交换堆顶元素和堆的最后一个元素后，堆的大小减小 1。</p></li></ol><p>堆排序的作用是对数组进行原地<code>(in-place)</code>排序，具有稳定的时间复杂度 <code>O(nlogn)</code>。堆排序相比于其他排序算法的一个优点是，它不需要额外的空间来存储临时数据，因此空间复杂度是 <code>O(1)</code>。另外，堆排序的最坏、平均和最好情况下的时间复杂度都是 <code>O(nlogn)</code>，因此在大多数情况下具有较好的性能。</p><p>堆排序的另一个重要应用是在优先队列中，用于高效地维护具有优先级的元素集合。通过使用堆数据结构，可以实现高效的插入、删除和查找操作。</p></li></ul></li></ol><h2 id="5-例题">5.例题</h2><blockquote><p>原题链接：<a href="https://www.acwing.com/problem/content/840/">838. 堆排序 - AcWing题库</a></p></blockquote><p>这个题很有学习价值。由于这代题目时间复杂度卡的比较死，所以思路一共经历了如下的三个过程</p><ul class="lvl-0"><li class="lvl-2"><p>过程一：很粗暴的堆排序，先构造大根堆得到堆顶的最大元素，再将最大元素固定到数组末尾，并对剩下的元素（未固定的元素）再求大根堆，以此模式依次将每一轮的最大元素依次固定到数组的末端，最后得到严格的从小到大的数组。</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>#include <algorithm>using namespace std;const int N = 1e5 + 10;int a[N];int n, m;void down(int x) {//构造大根堆的down,堆顶为最大元素    int t = x;//t是要交换到的位置，且保证一个节点的左节点比右节点小        if (x*2 <= n && a[2*x] > a[t])  t = 2*x;    if (x*2+1 <= n && a[2*x+1] > a[t])  t = 2*x+1;        if (t>x) {        swap(a[x],a[t]);        down(t);    }}int main () {    cin >> n >> m;    for (int i = 1 ; i <= n ; i ++ ) cin >> a[i];        while (n) {        for (int i = n/2 ; i>=1 ; i -- ) down(i);//构造大根堆        swap(a[n], a[1]);//再将大根堆堆顶的元素（最大值）固定到数组末尾        n--;//再对没有固定的元素再构造大根堆    }        for (int i = 1 ; i <= m ; i++)   cout << a[i] << ' ';    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>过程二：过程一的小优化，从n次的<strong>整体建大根堆</strong>过程变成m次的<strong>整体建小根堆</strong>过程，减少了(n-m)次整体建堆的过程</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">while (m--) {    for (int i = n/2 ; i>=1 ; i -- ) down(i);//先构造小根堆    printf("%d ",a[1]);//输出小根堆堆顶元素    swap(a[n], a[1]);//再将小根堆堆顶的元素（最小值）固定到数组末尾    n--;//再对没有固定的元素再构造小根堆}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>过程三：不再完整的建立大根堆或者小根堆，而是采用<strong>部分建堆</strong>，建立一次小根堆之后，输出小根堆堆顶元素，再将小根堆堆顶元素固定到数组末尾，再对置换到堆顶的原数组末尾元素进行<code>down()</code>操作就能每次在堆顶得到一个最小元素</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">while (m--) {    printf("%d ",a[1]);//输出小根堆堆顶元素    swap(a[n], a[1]);//再将小根堆堆顶的元素（最小值）固定到数组末尾    n--;    down(1);//没有整体进行down()操作，而不是采用循环整体建堆}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——并查集</title>
      <link href="/20231123/shu-ju-jie-gou-bing-cha-ji/"/>
      <url>/20231123/shu-ju-jie-gou-bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<h1>区间合并</h1><blockquote><p>指路一篇讲的很好的文章：<a href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) : 并查集 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="1-数据结构">1.数据结构</h2><blockquote><p>并查集主要用途：</p><ol><li class="lvl-3">快速将两个集合合并（时间复杂度接近<code>O(1)</code>）</li><li class="lvl-3">快速查询两个元素是否在一个集合当中（时间复杂度接近<code>O(1)</code>）</li></ol><p>基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。<strong>每个节点储存它的父节点</strong>，p[x]表示x的父节点。问题1：如何判断树根：<input type="checkbox" id="checkbox4" checked="true"><label for="checkbox4">== x)</label>问题2：如何求x的集合编号：<input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">!= x) x = p[x]</label>;(常用优化方法：路径压缩)<br>问题3：如何合并两个集合：<code>px</code>是<code>x</code>的集合编号，<code>py</code>是<code>y</code>的集合编号。<input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2">= y</label>;</p></blockquote><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20231101145546570.png" alt="image-20231101145546570" style="zoom:50%;"><p>数据结构要点：</p><ul class="lvl-0"><li class="lvl-2"><p>不是真正用树状存储，而是用数组模拟树状存储。</p></li><li class="lvl-2"><p>每个节点存储的是其父节点。所以除了根节点，不可能有节点指向自身<code>即(p[x]==x)</code></p></li><li class="lvl-2"><p>将两个集合合并：使一个集合的根节点指向另一个集合的根</p></li></ul><h2 id="2-基础代码实现">2.基础代码实现</h2><blockquote><p><strong>存在问题</strong>：效率低下。随着不断合并，会形成一段长长的链，底部找到根节点会变得越来越难</p></blockquote><p><strong>初始化</strong></p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">for (int i = 1; i <= n; ++i)fa[i] = i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>初始化先将所有的节点指向自身（每个节点都是一个孤立的集合）。</p><p><strong>查询</strong></p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int find(int x) {    if(fa[x] == x)return x;    elsereturn find(fa[x]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>合并</strong></p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">inline void merge(int i, int j) {    fa[find(i)] = find(j);//使 i 点所在集合的根节点指向 j 点所在的根节点}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-代码优化">3.代码优化</h2><h3 id="3-1路径压缩（最常用，但是比较极端）">3.1路径压缩（最常用，但是比较极端）</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int find(int x) {    return x == fa[x] ? x : (fa[x] = find(fa[x]));//每个节点均指向其对应的根节点}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>图解：</p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/%25E8%25B7%25AF%25E5%25BE%2584%25E5%258E%258B%25E7%25BC%25A9.jpg" alt="路径压缩" style="zoom:50%;"><h3 id="3-2路径分裂（基本不用）">3.2路径分裂（基本不用）</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int find(int x) {    while (x != p[x]) {    int p = p[x];    p[x] = p[p[x]];    x = p;    }return x;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3路径减半（基本不用）">3.3路径减半（基本不用）</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int find(int x) {    while (x != p[x]) {//x与x的父节点均指向其祖父节点的父节点        p[x] = p[p[x]];        x = p[x];    }    return x;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4按秩合并（路径压缩的优化）">3.4按秩合并（路径压缩的优化）</h3><p><strong>原理</strong>：小树向大数合并。用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank（<strong>秩</strong>）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p><p><strong>初始化（按秩合并）</strong></p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">inline void init(int n) {    for (int i = 1; i <= n; ++i) {        fa[i] = i;        rank[i] = 1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>合并（按秩合并）</strong></p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">inline void merge(int i, int j) {    int x = find(i), y = find(j);    //先找到两个根节点    if (rank[x] <= rank[y])        fa[x] = y;    else        fa[y] = x;    if (rank[x] == rank[y] && x != y)        rank[y]++;                   //如果深度相同且根节点不同，则新的根节点的深度+1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-AcWing代码模板">4.<code>AcWing</code>代码模板</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">(1)朴素并查集：    int p[N]; //存储每个点的祖宗节点    // 返回x的祖宗节点    int find(int x) {        if (p[x] != x) p[x] = find(p[x]);        return p[x];    }    // 初始化，假定节点编号是1~n    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 合并a和b所在的两个集合：    p[find(a)] = find(b);(2)维护size的并查集：    int p[N], size[N];    //p[]存储每个点的祖宗节点, size[]只对祖宗节点的有意义，表示祖宗节点所在集合中的点的数量    // 返回x的祖宗节点    int find(int x) {        if (p[x] != x) p[x] = find(p[x]);        return p[x];    }    // 初始化，假定节点编号是1~n    for (int i = 1; i <= n; i ++ ) {        p[i] = i;        size[i] = 1;    }    // 合并a和b所在的两个集合：    size[find(b)] += size[find(a)];    p[find(a)] = find(b);(3)维护到祖宗节点距离的并查集：    int p[N], d[N];    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离    // 返回x的祖宗节点    int find(int x) {        if (p[x] != x) {            int u = find(p[x]);            d[x] += d[p[x]];            p[x] = u;        }        return p[x];    }    // 初始化，假定节点编号是1~n    for (int i = 1; i <= n; i ++ ) {        p[i] = i;        d[i] = 0;    }    // 合并a和b所在的两个集合：    p[find(a)] = find(b);    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-例题解析">5.例题解析</h2><blockquote><p>原题链接：<a href="https://www.acwing.com/problem/content/242/">240. 食物链 - AcWing题库</a></p><p>题解：<a href="https://www.acwing.com/activity/content/code/content/45325/">AcWing 240. 食物链 - AcWing</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——区间合并</title>
      <link href="/20231123/ji-chu-suan-fa-qu-jian-he-bing/"/>
      <url>/20231123/ji-chu-suan-fa-qu-jian-he-bing/</url>
      
        <content type="html"><![CDATA[<h1>区间合并</h1><h2 id="1-基本思想">1.基本思想</h2><p><strong>问题描述</strong><br>输入一个区间的合集，将有重叠的区间合并成一个新的区间（本题中后一个区间的起点和前一个区间的终点重合，也算两个区间重叠，需要合并）</p><p><strong>算法思想</strong><br>先按左端点排序，再维护一个区间，与后面一个个区间进行三种情况（见下图）的比较，存储到数组/向量中</p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20231023195917607.png" alt="image-20231023195917607" style="zoom:67%;"><h2 id="2-参考题目与代码实现（AcWing-803-区间合并）">2.参考题目与代码实现（<code>AcWing</code> 803.区间合并）</h2><blockquote><p><strong>题目描述</strong><br>给定<code>n</code>个区间 <code>[li,ri]</code>，要求合并所有有交集的区间。注意如果在端点处相交，也算有交集。输出合并完成后的区间个数。例如：<code>[1,3]</code> 和 <code>[2,6]</code> 可以合并为一个区间 <code>[1,6]</code> 。</p><p><strong>输入格式</strong><br>第一行包含整数<code>n</code>。接下来<code>n</code>行，每行包含两个整数<code>l</code>和<code>r</code>。</p><p><strong>输出格式</strong><br>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><p><strong>数据范围</strong><br>$$<br>1 \le n \le 1e5\<br>-10^9 \le l_i \le r_i \le 10^9<br>$$<br><strong>样例</strong><br>输入样例：</p><pre class="line-numbers language-language-markdown"><code class="language-language-markdown">51 22 45 67 87 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出样例：</p><pre class="line-numbers language-language-markdown"><code class="language-language-markdown">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><strong>代码实现</strong></p><pre class="line-numbers language-language-c++"><code class="language-language-c++">#include <iostream>#include <vector>#include <algorithm>using namespace std;typedef pair<int, int> PII;void merge(vector<PII> &segs) {    vector<PII> res;    sort(segs.begin(), segs.end());//根据左端点从小到大进行排序    /*sort函数对pair进行排序，默认情况下，先对first进行从小到大排序，fitst相同再根据second从小到大进行排序*/    int st = -2e9, ed = -2e9;//维护区间初始化    for (auto seg : segs)        if (ed < seg.first)//如果下一个区间的起点在当前维护区间外面（右端点的右侧）        {            if (st != -2e9) res.push_back({st, ed});//存储原维护区间            st = seg.first, ed = seg.second;//新的维护区间建立        }        else ed = max(ed, seg.second);//否则，则合并    if (st != -2e9) res.push_back({st, ed});//存储最后一个维护区间    segs = res;}int main() {    int n;    scanf("%d", &n);    vector<PII> segs;    for (int i = 0; i < n; i ++ ) {        int l, r;        scanf("%d%d", &l, &r);        segs.push_back({l, r});    }//输入与存储    merge(segs);//区间合并主过程        cout << segs.size() << endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——离散化</title>
      <link href="/20230920/ji-chu-suan-fa-chi-san-hua/"/>
      <url>/20230920/ji-chu-suan-fa-chi-san-hua/</url>
      
        <content type="html"><![CDATA[<h1>离散化</h1><blockquote><p>参考知乎文章：<a href="https://zhuanlan.zhihu.com/p/112497527">算法学习笔记(19): 离散化 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="1-离散化定义">1. 离散化定义</h2><blockquote><p><strong>离散化</strong>，就是当我们只关心数据的<strong>大小关系</strong>时，用<strong>排名</strong>代替<strong>原数据</strong>进行处理的一种预处理方法。离散化本质上是一种<strong>哈希</strong>，它在保持原序列大小关系的前提下把其映射成正整数。当原数据很大或含有负数、小数时，难以表示为数组下标，一些算法和数据结构（如BIT）无法运作，这时我们就可以考虑将其离散化。</p></blockquote><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230915214921191.png" alt="image-20230915214921191" style="zoom:50%;"><blockquote><p>值域很大，但是值很稀疏，每次用到的只有它们的相对关系</p></blockquote><h2 id="2-算法模板">2. 算法模板</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">vector<int> alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置{    int l = 0, r = alls.size() - 1;    while (l < r)    {        int mid = l + r >> 1;        if (alls[mid] >= x) r = mid;        else l = mid + 1;    }    return r + 1; // 映射到1, 2, ...n}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-例题与题解">3. 例题与题解</h2><p>原题链接：<a href="https://www.acwing.com/problem/content/804/">802. 区间和 - AcWing题库</a></p><blockquote><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c 。</p><p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 $[l,r]$$之间的所有数的和。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>接下来 n 行，每行包含两个整数 x 和 c。</p><p>再接下来 m 行，每行包含两个整数 l 和 r。</p><p><strong>输出格式</strong></p><p>共 m 行，每行输出一个询问中所求的区间内数字和。</p><p><strong>数据范围</strong><br>$$<br>-10<sup>9&lt;x&lt;10</sup>9\<br>1≤n,m≤10^5\<br>−10<sup>9≤l≤r≤10</sup>9\<br>−10000≤c≤10000\<br>$$<br><strong>输入样例</strong>：</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">3 31 23 67 51 34 67 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出样例</strong>：</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">805<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p>题解与代码：<a href="https://www.acwing.com/solution/content/13511/">AcWing 802. 画个图辅助理解~ - AcWing</a></p><blockquote><p>C++ 代码</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>#include <vector>#include <algorithm>using namespace std;const int N = 300010; //n次插入和m次查询相关数据量的上界int n, m;int a[N];//存储坐标插入的值int s[N];//存储数组a的前缀和vector<int> alls;  //存储（所有与插入和查询有关的）坐标vector<pair<int, int>> add, query; //存储插入和询问操作的数据int find(int x) { //返回的是输入的坐标的离散化下标 int l = 0, r = alls.size() - 1; while (l < r) {     int mid = l + r >> 1;     if (alls[mid] >= x) r = mid;     else l = mid + 1; } return r + 1;}int main() { scanf("%d%d", &n, &m); for (int i = 1; i <= n; i++) {     int x, c;     scanf("%d%d", &x, &c);     add.push_back({x, c});     alls.push_back(x); } for (int i = 1; i <= m; i++) {     int l , r;     scanf("%d%d", &l, &r);     query.push_back({l, r});     alls.push_back(l);     alls.push_back(r); }//排序，去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); //执行前n次插入操作 for (auto item : add) {     int x = find(item.first);     a[x] += item.second; } //前缀和 for (int i = 1; i <= alls.size(); i++) s[i] = s[i-1] + a[i]; //处理后m次询问操作 for (auto item : query) {     int l = find(item.first);     int r = find(item.second);     printf("%d\n", s[r] - s[l-1]); }return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230918154413348.png" alt="image-20230918154413348"></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230918154434948.png" alt="image-20230918154434948"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——位运算</title>
      <link href="/20230920/ji-chu-suan-fa-wei-yun-suan/"/>
      <url>/20230920/ji-chu-suan-fa-wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<h1>位运算</h1><h2 id="1-n的二进制表示中第k位是1-0？">1. <code>n</code>的二进制表示中第<code>k</code>位是1/0？</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">//求n的第k位数字: n >> k & 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>思想：</p><ol><li class="lvl-3"><p>先把第<code>k</code>位移到最后一位<code>n &gt;&gt; k</code></p></li><li class="lvl-3"><p>看各位是几<code>x&amp;1</code></p></li></ol><hr><h2 id="2-lowbit-操作——返回x的最后一位1是多少">2. <code>lowbit()</code>操作——返回<code>x</code>的最后一位1是多少</h2><ul class="lvl-0"><li class="lvl-2"><p><strong>树状数组的基本操作</strong></p></li><li class="lvl-2"><p><code>lowbit(x) —— x &amp; (-x)</code><strong>作用</strong>：<strong>返回x的最后一位1</strong>（除了原<code>x</code>的最低为1的比特位为1，其余比特位均为0）</p></li></ul><blockquote><ul class="lvl-1"><li class="lvl-2"><p><mark><strong>原理</strong>——<code>x &amp; (-x)</code></mark><br>在C/C++中，x的负数即为x取反加一，即**<mark>(-x) = ~x + 1</mark>**<br>故<code>x &amp; (-x)</code>等价于<code>x &amp; ~x + 1</code></p></li><li class="lvl-2"><p><mark>模拟<code>lowbit()</code>作用</mark>：<br>x = 101110010<strong>1</strong>000，则 (-x) = 010001101<strong>0</strong>111，则 (-x+1) = 010001101<strong>1</strong>000，则   x &amp; (-x+1) = 000000000<strong>1</strong>000；</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——双指针算法</title>
      <link href="/20230920/ji-chu-suan-fa-shuang-zhi-zhen-suan-fa/"/>
      <url>/20230920/ji-chu-suan-fa-shuang-zhi-zhen-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1>双指针算法</h1><h2 id="1-算法思想">1. 算法思想</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">//普通双指针（时间复杂度为o(n^2)）：for (int i = 0 ; i < n ; i ++)    for (int j = 0 ; j < n ; j ++)        ……/*执行题目具体要求*/        //运用某些性质将时间复杂度优化到o(n)for (int i = 0 ; i < n ; i++){    while (j <= i && check(...))j++    ……/*执行题目具体要求*/}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过某些条件限制某个指针，使时间复杂度优化到o(n)</p><h2 id="2-常见问题分类">2. 常见问题分类</h2><p>(1) 对于一个序列，用两个指针维护一段区间<br>(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p><h2 id="3-例题">3. 例题</h2><p>“<strong>连续最长不重复子序列</strong>”</p><ul class="lvl-0"><li class="lvl-2"><p>给定一个长度为<code>n</code>的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><p><strong>输入格式</strong></p><p>第一行包含整数<code>n</code>。</p><p>第二行包含<code>n</code>个整数（均在$0-10^5$范围内），表示整数序列。</p><p><strong>输出格式</strong></p><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p><p><strong>数据范围</strong></p><p>$1\le n \le 10^5$</p><p><strong>输入样例</strong>：</p><pre class="line-numbers language-language-markdown"><code class="language-language-markdown">51 2 2 3 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>输出样例</strong>：</p><pre class="line-numbers language-language-markdown"><code class="language-language-markdown">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>答案代码</strong>：</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>using namespace std;const int N = 100010;int n;int q[N], s[N];int main(){    scanf("%d", &n);    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);    int res = 0;    for (int i = 0, j = 0; i < n; i ++ )    {        s[q[i]] ++ ;        while (j < i && s[q[i]] > 1) s[q[j ++ ]] -- ;        res = max(res, i - j + 1);    }    cout << res << endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——十大排序算法总结（转载）</title>
      <link href="/20230920/ji-chu-suan-fa-shi-da-pai-xu-suan-fa-zong-jie-zhuan-zai/"/>
      <url>/20230920/ji-chu-suan-fa-shi-da-pai-xu-suan-fa-zong-jie-zhuan-zai/</url>
      
        <content type="html"><![CDATA[<h1>十大排序算法总结(转载)</h1><p>本文章仅供个人在个人博客上面参考！！！</p><p>原文写的很好，虽然有些部分我个人感觉是有点问题（读者自行斟酌），推荐阅读原文：<a href="https://www.acwing.com/solution/content/26513/">AcWing 785. 十大排序算法总结 - AcWing</a></p><blockquote><p>排序算法的分类：</p><ol><li class="lvl-3">插入：插入，折半插入，希尔</li><li class="lvl-3">交换：冒泡，快速</li><li class="lvl-3">选择：简单选择，堆</li><li class="lvl-3">归并：归并（不只二路归并）</li><li class="lvl-3">基数：基数排序</li></ol></blockquote><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230915192157035.png" alt="image-20230915192157035"></p><h2 id="1-插入排序">1. 插入排序</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void insert_sort(){    for (int i = 1; i < n; i ++ )    {        int x = a[i];        int j = i-1;    while (j >= 0 && x < a[j])    {        a[j+1] = a[j];        j -- ;    }    a[j+1] = x;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-选择排序">2. 选择排序</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void select_sort(){    for (int i = 0; i < n; i ++ )    {        int k = i;        for (int j = i+1; j < n; j ++ )        {            if (a[j] < a[k])                k = j;        }        swap(a[i], a[k]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-冒泡排序">3. 冒泡排序</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void bubble_sort(){    for (int i = n-1; i >= 1; i -- )    {        bool flag = true;        for (int j = 1; j <= i; j ++ )            if (a[j-1] > a[j])            {                swap(a[j-1], a[j]);                flag = false;            }        if (flag) return;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-希尔排序">4. 希尔排序</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void shell_sort(){    for (int gap = n >> 1; gap; gap >>= 1)    {        for (int i = gap; i < n; i ++ )        {            int x = a[i];            int j;            for (j = i; j >= gap && a[j-gap] > x; j -= gap)                a[j] = a[j-gap];            a[j] = x;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-快速排序（最快）">5. 快速排序（最快）</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void quick_sort(int l, int r){    if (l >= r) return ;int x = a[l+r>>1], i = l-1, j = r+1;while (i < j){   while (a[++ i] < x);    while (a[-- j] > x);    if (i < j) swap(a[i], a[j]);}sort(l, j), sort(j+1, r);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-归并排序">6. 归并排序</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void merge_sort(int l, int r){    if (l >= r) return;        int temp[N];    int mid = l+r>>1;    merge_sort(l, mid), merge_sort(mid+1, r);        int k = 0, i = l, j = mid+1;    while (i <= mid && j <= r)    {        if (a[i] < a[j]) temp[k ++ ] = a[i ++ ];        else temp[k ++ ] = a[j ++ ];}    while (i <= mid) temp[k ++ ] = a[i ++ ];while (j <= r) temp[k ++ ] = a[j ++ ];    for (int i = l, j = 0; i <= r; i ++ , j ++ ) a[i] = temp[j];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-堆排序">7. 堆排序</h2><p>（须知此排序为使用了模拟堆，为了使最后一个非叶子节点的编号为n/2，数组编号从1开始）<br><a href="https://www.cnblogs.com/wanglei5205/p/8733524.html">https://www.cnblogs.com/wanglei5205/p/8733524.html</a></p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void down(int u){    int t = u;    if (u<<1 <= n && h[u<<1] < h[t]) t = u<<1;    if ((u<<1|1) <= n && h[u<<1|1] < h[t]) t = u<<1|1;    if (u != t)    {        swap(h[u], h[t]);        down(t);    }}int main(){    for (int i = 1; i <= n; i ++ ) cin >> h[i];    for (int i = n/2; i; i -- ) down(i);    while (true)    {        if (!n) break;        cout << h[1] << ' ';        h[1] = h[n];        n -- ;        down(1);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-基数排序">8. 基数排序</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int maxbit(){    int maxv = a[0];    for (int i = 1; i < n; i ++ )        if (maxv < a[i])            maxv = a[i];    int cnt = 1;    while (maxv >= 10) maxv /= 10, cnt ++ ;return cnt;}void radixsort(){    int t = maxbit();    int radix = 1;    for (int i = 1; i <= t; i ++ )    {        for (int j = 0; j < 10; j ++ ) count[j] = 0;        for (int j = 0; j < n; j ++ )        {            int k = (a[j] / radix) % 10;            count[k] ++ ;        }        for (int j = 1; j < 10; j ++ ) count[j] += count[j-1];        for (int j = n-1; j >= 0; j -- )        {            int k = (a[j] / radix) % 10;            temp[count[k]-1] = a[j];            count[k] -- ;        }        for (int j = 0; j < n; j ++ ) a[j] = temp[j];        radix *= 10;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-计数排序">9. 计数排序</h2><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void counting_sort(){    int sorted[N];    int maxv = a[0];    for (int i = 1; i < n; i ++ )        if (maxv < a[i])            maxv = a[i];    int count[maxv+1];    for (int i = 0; i < n; i ++ ) count[a[i]] ++ ;    for (int i = 1; i <= maxv; i ++ ) count[i] += count[i-1];    for (int i = n-1; i >= 0; i -- )    {        sorted[count[a[i]]-1] = a[i];        count[a[i]] -- ;    }    for (int i = 0; i < n; i ++ ) a[i] = sorted[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-桶排序">10. 桶排序</h2><p>（基数排序是桶排序的特例，优势是可以处理浮点数和负数，劣势是还要配合别的排序函数）</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">vector<int> bucketSort(vector<int>& nums) {    int n = nums.size();    int maxv = *max_element(nums.begin(), nums.end());    int minv = *min_element(nums.begin(), nums.end());    int bs = 1000;    int m = (maxv-minv)/bs+1;    vector<vector<int> > bucket(m);        for (int i = 0; i < n; ++i) {        bucket[(nums[i]-minv)/bs].push_back(nums[i]);    }    int idx = 0;        for (int i = 0; i < m; ++i) {        int sz = bucket[i].size();        bucket[i] = quickSort(bucket[i]);        for (int j = 0; j < sz; ++j) {            nums[idx++] = bucket[i][j];        }    }        return nums;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——前缀和与差分</title>
      <link href="/20230914/ji-chu-suan-fa-qian-zhui-he-yu-chai-fen/"/>
      <url>/20230914/ji-chu-suan-fa-qian-zhui-he-yu-chai-fen/</url>
      
        <content type="html"><![CDATA[<h1>前缀和与差分</h1><h2 id="1-一维前缀和">1.一维前缀和</h2><h3 id="1-1-前缀和的定义">1.1 前缀和的定义</h3><p>$ s[n]=$一个数组中（下标从1开始）前n个数据的和</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230914142050540.png" alt="image-20230914142050540"></p><h3 id="1-2-算法思想与模板">1.2 算法思想与模板</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">//数组中下标含0的元素始终为0，例如a[0] = 0, s[0] = 0for (int i = 1; i <= n; i ++ ){cin >> a[i];s[i] = s[i - 1] + a[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以(o1)的时间复杂度得到某块区间的总和</p><h2 id="2-二维前缀和">2. 二维前缀和</h2><h3 id="2-1-算法思想与模板">2.1 算法思想与模板</h3><p>利用<strong>容斥原理</strong></p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">//数组中下标含0的元素始终为0，例如a[0][0] = 0, s[0][0] = 0; a[0][1] = 0......S[i, j] = 第i行j列格子左上部分所有元素的和//以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-一维差分">3. 一维差分</h2><blockquote><p>差分部分参考了CSDN上的文章，原文链接：</p><p><a href="https://blog.csdn.net/weixin_43914593/article/details/113782108">差分 --算法竞赛专题解析（32）_罗勇军的博客-CSDN博客</a></p></blockquote><h3 id="3-1-一维差分的定义">3.1 一维差分的定义</h3><blockquote><p>讨论这样一个场景：</p><ol><li class="lvl-3"><p>给定一个长度为<code>n</code>的一维数组<code>a[]</code>，数组内每个元素有初始值。</p></li><li class="lvl-3"><p>修改操作：做<code>m</code>次区间修改，每次修改对区间内所有元素做相同的加减操作。例如第<code>i</code>次修改，把区间$[ L_i , R_i ] $(<strong>注意是闭区间</strong>)内所有元素加上$d_i $。</p></li><li class="lvl-3"><p>询问操作：询问一个元素的新值是多少。</p></li></ol></blockquote><ul class="lvl-0"><li class="lvl-2"><p>如果简单地用暴力法编码，那么每次修改的复杂度是<code>O(n)</code>的，m次修改共<code>O(mn)</code>，总复杂度<code>O(mn)</code>，效率很差。利用差分法，可以把复杂度减少到<code>O(m+n)</code>。</p></li><li class="lvl-2"><p>在<strong>差分法</strong>中，用到了两个数组：原数组<code>a[]</code>、差分数组<code>D[]</code>。<br><strong>差分数组<code>D[ ]</code>的<mark>定义</mark><strong>是<code>D[k] = a[k] − a[k − 1]</code>，即</strong><mark>原数组<code>a[ ]</code>的相邻元素的差</mark></strong>，也可以假想成**<mark><code>a[n]</code>是差分数组<code>D[]</code>的前n个元素的和</mark>**。</p><ul class="lvl-2"><li class="lvl-4">从定义可以推出<code>a[k] = D[1] + D[2] + . . . + D[k] </code>，也就是说，<code>a[]是D[]</code>的前缀和。这个公式揭示了<code>a[]</code>和<code>D[]</code>的关系，“<strong>差分是前缀和的逆运算</strong>”，它把求<code>a[k]</code>转化为求D的前缀和。</li><li class="lvl-4">注意，<code>a[]</code>和<code>D[]</code>的值都可能为负，下面图中所有的<code>D[]</code>都是长度为正的线段，只是为了方便图示。</li></ul></li></ul><p><mark>理解：将<code>a[]</code>想象成线上的点，将<code>D[]</code>想象成点前的区间</mark><br><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230914153338835.png" alt="image-20230914153338835"></p><h3 id="3-2-算法思想">3.2 算法思想</h3><p>把区间<code>[ L , R ]</code>内每个元素加上<code>d</code> ，对应的<code>D[ ]</code> 做以下操作：</p><ol><li class="lvl-3"><p>把D [ L ] 加上d ：</p></li></ol><pre class="line-numbers language-language-cpp"><code class="language-language-cpp"> D[L] += d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li class="lvl-3"><p>把D [ R + 1 ] 减去d ：</p></li></ol><pre class="line-numbers language-language-cpp"><code class="language-language-cpp"> D[R+1] -= d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每次操作只需要修改区间<code>[L,R]</code>的两个端点的<code>D[]</code>值，复杂度是<code>O(1)</code>的。经过这种操作后，原来直接在<code>a[]</code>上做的复杂度为<code>O(n)</code>的区间修改操作，就变成了在<code>D[]</code>上做的复杂度为<code>O(1)</code> 端点操作。</p><blockquote><p>利用<code>D[]</code>，能精确地实现只修改区间内元素的目的，而不会修改区间外的<code>a[]</code>值。因为前缀和<input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">= D[1] + D[2] + . . . + D[x]</label>，有：<br>1）<code>1 ≤ x &lt; L</code> ，前缀和<code>a[x]</code>不变；<br>2）<code>L ≤ x ≤ R </code>，前缀和<code>a[x]</code>增加了<code>d</code> ；<br>3）<code>R &lt; x ≤ N</code> ，前缀和<code>a[x]</code>不变，因为被<code>D[R+1]</code>中减去的<code>d</code>抵消了。</p></blockquote><p>完成区间修改并得到<code>D[]</code>后，最后用<code>D[]</code>计算<code>a[]</code>，复杂度是<code>O(n)</code>的。<code>m</code>次区间修改和1次查询，总复杂度为<code>O(m+n)</code>，比暴力法的<code>O(mn)</code>好多了。</p><h3 id="3-3-算法模板">3.3 算法模板</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">//数组中下标为1的元素始终为0,例如a[0] = 0, D[0] = 0;//给区间[l, r]中的每个数加上c：D[l] += c;D[r + 1] -= c;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-差分的局限性">3.4 差分的局限性</h3><p>​利用差分数组<code>D[]</code>可以把<code>O(n)</code>的区间修改，变成<code>O(1)</code>的端点修改，从而提高了修改操作的效率。<br>  但是，一次查询操作，即查询某个<code>a[i]</code>，需要用<code>D[]</code>计算整个原数组<code>a[]</code>，计算量是<code>O(n)</code>的，即一次查询的复杂度是<code>O(n)</code>的。在上面的例题中，如果查询不是发生了一次，而是这样：有<code>m</code>次修改，有<code>k</code>次查询，且修改和查询的顺序是随机的。此时总复杂度是：m次修改，复杂度<code>O(m)</code>，<code>k</code>次查询复杂度<code>O(kn)</code>，总复杂度<code>O(m+kn)</code>。还不如直接用暴力法，总复杂度<code>O(mn+k)</code>。<br>  这种题型是“<strong>区间修改+单点查询</strong>”，用差分数组往往不够用。因为<strong>差分数组对“区间修改”很高效，但是对“单点查询”并不高效</strong>。此时需要用树状数组和线段树来求解</p><h2 id="4-二维差分">4. 二维差分</h2><h3 id="4-1-算法思想">4.1 算法思想</h3><p><mark>将<code>a[][]</code>想象成图上的每个点，将<code>D[][]</code>想象成点前的每一块，每一个点的大小等于从左上角到该点所能划出矩形的面积</mark></p><blockquote><p>只有</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">D[x1, y1] += c;D[x2 + 1, y1] -= c;D[x1, y2 + 1] -= c;D[x2 + 1, y2 + 1] += c;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样划分，才能仅影响蓝色区域中的九个点</p></blockquote><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230914155056763.png" alt="image-20230914155056763"></p><h3 id="4-2-算法模板">4.2 算法模板</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">//数组中下标含0的元素始终为0,例如a[0][0] = 0, D[0][0] = 0; a[0][1] = 0......//给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：D[x1, y1] += c;D[x2 + 1, y1] -= c;D[x1, y2 + 1] -= c;D[x2 + 1, y2 + 1] += c;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——高精度大数运算</title>
      <link href="/20230914/ji-chu-suan-fa-gao-jing-du-da-shu-yun-suan/"/>
      <url>/20230914/ji-chu-suan-fa-gao-jing-du-da-shu-yun-suan/</url>
      
        <content type="html"><![CDATA[<h1>高精度大数运算</h1><h2 id="1-高精度定义">1. 高精度定义</h2><p>在<code>C/C++</code>中，各种数据类型都是有一定取值范围的，但在实际生产/计算中，有些位数很多的大数是C语言中的数据类型无法表示的。比如<code>len(a) = 1e10</code>，则在类C语言中，<code>a</code>无法直接进行计算，我们需要用数组或者<code>vector</code>来进行模拟计算。相关数据类型取值范围如下；</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">类型名                  取值范围signed char                   -128~127unsigned char         0~255short int                   -32768~32767int             -2147483648~2147483647unsigned int  0~4294967295long                      -2147483648~2141483647unsigned long  0~4294967295long long       -9223372036854775808~9223372036854775807unsigned long long       0~18446744073709551615<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时我们需要高精度计算方法。</p><h2 id="2-高精度加法（两个高精度整数相加）">2. 高精度加法（两个高精度整数相加）</h2><h3 id="2-1-算法思想">2.1 算法思想</h3><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230911193154998.png" alt="image-20230911193154998"></p><h3 id="2-2-算法模板">2.2 算法模板</h3><p><mark>计算</mark>模板：</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">// C = A + B, A >= 0, B >= 0vector<int> add(vector<int> &A, vector<int> &B){    if (A.size() < B.size()) return add(B, A);    vector<int> C;    int t = 0;    for (int i = 0; i < A.size(); i ++ )    {        t += A[i];        if (i < B.size()) t += B[i];        C.push_back(t % 10);        t /= 10;    }    if (t) C.push_back(t);    return C;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><u>大整数<mark>存储</mark>模板</u>（大端存储会极大简化计算过程,需考虑进位）：</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int main(){    std::string s1,s2;    cin >> s1 >> s2;    vector<int> a,b;    for (int i = s1.size()-1 ; i >= 0 ; i--)     a.push_back( s1[i] - '0');//a,b采用大端存储的方式，数字低位存放在向量的低位，方便对高位数据进行操作，进位/去除前导0    for (int i = s2.size()-1 ; i >= 0 ; i--)     b.push_back( s2[i] - '0');    auto c = add(a,b);//auto表示自动选择函数的返回类型给到c,c采用为大段存储        for (int i = c.size() - 1 ; i >= 0 ; i--)   cout << c[i];        system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-高精度减法（两个高精度整数相减）">3. 高精度减法（两个高精度整数相减）</h2><h3 id="3-1-算法思想">3.1 算法思想</h3><p>同竖式减法</p><h3 id="3-2-算法模板">3.2 算法模板</h3><p><u><mark>存储</mark>方式同高精度加法</u></p><p><mark>计算</mark>模板（假设<strong>AB均为整数且A&gt;=B</strong>的前提下）：</p><ul class="lvl-0"><li class="lvl-2"><p>采用大端存储，<strong><mark>去除前导0</mark></strong>（因为采用大端存储，所以高位的0要除去，比如减法所得结果为009，应输出9，则需要去掉前面高位的两个0）</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">// C = A - B, 满足A >= B, A >= 0, B >= 0vector<int> sub(vector<int> &A, vector<int> &B){    vector<int> C;    for (int i = 0, t = 0; i < A.size(); i ++ )    {        t = A[i] - t;//此时t == 被减数减去上一位的借位        if (i < B.size()) t -= B[i]; //此时t == t-减数        C.push_back( (t + 10) % 10 );        //当t = 被减数 - 借位 - 减数 > 0 时，(t + 10) % 10表示差        //当t = 被减数 - 借位 - 减数 < 0 时，(t + 10) % 10表示借位后的差        if (t < 0) t = 1; //标记借位        else t = 0;//标记未借位    }    while (C.size() > 1 && C.back() == 0) C.pop_back();//去除前导0    return C;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark>比较模板</mark>（比较两个高精度整数大小）</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">bool cmp(vector<int> &A, vector<int> &B){    if (A.size() != B.size()) return A.size() > B.size();    //返回 “A比B长度（位数）大” 这个布尔表达式的结果。即当A长度大于B时，布尔表达式成立，返回true；当A长度小于B时，布尔表达式不成立，返回false。    for (int i = A.size() - 1; i >= 0; i -- )        if (A[i] != B[i])            return A[i] > B[i];    //返回 “A的元素值比B大” 这个布尔表达式的结果。当A的元素值大于B的元素值时，布尔表达式成立，返回true；当A的元素值小于B的元素值时，布尔表达式不成立，返回false。    return true;//A与B相等}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-高精度乘法（一个高精度整数乘与一个低精度整数）">4. 高精度乘法（一个高精度整数乘与一个低精度整数）</h2><h3 id="4-1-算法思想">4.1 算法思想</h3><p>不同于一般竖式乘法</p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230911212419667.png" alt="image-20230911212419667" style="zoom: 40%;"><h3 id="4-2-算法模板">4.2 算法模板</h3><p><mark>存储</mark>模板与高精度加法类似</p><p><strong>乘法</strong>模版与<strong>加法</strong>模板类似</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">// C = A * b, A >= 0, b >= 0vector<int> mul(vector<int> &A, int b){    vector<int> C;    int t = 0;    for (int i = 0; i < A.size() || t; i ++ )//注意退出条件不仅仅是i < A.size()，还要考虑乘法进位的情况，即退出条件为i >= A.size() && t == 0    {        if (i < A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    }    while (C.size() > 1 && C.back() == 0) C.pop_back();//去除前导0，小精度整数为0的情况    return C;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-高精度除法（高精度除以低精度）">5. 高精度除法（高精度除以低精度）</h2><h3 id="5-1-算法思想">5.1 算法思想</h3><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230912130420351.png" alt="image-20230912130420351" style="zoom: 33%;"><h3 id="5-2-算法模板">5.2 算法模板</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">// A / b = C ... r, A >= 0, b > 0vector<int> div(vector<int> &A, int b, int &r){    vector<int> C;    r = 0;//r表示余数    for (int i = A.size() - 1; i >= 0; i -- )    {        r = r * 10 + A[i];        C.push_back(r / b);//上商        r %= b;    }    reverse(C.begin(), C.end());//将大端存储改为小端存储，方便去除前导0以及输出    while (C.size() > 1 && C.back() == 0) C.pop_back();//去除前导0    return C;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——二分法</title>
      <link href="/20230914/ji-chu-suan-fa-er-fen-fa/"/>
      <url>/20230914/ji-chu-suan-fa-er-fen-fa/</url>
      
        <content type="html"><![CDATA[<h1>二分法</h1><h2 id="1-基本思想">1. 基本思想</h2><p>二分的本质并<strong>不是</strong>单调性——有单调性一定可以二分，可以二分的不一定有单调性。</p><p><strong>二分的本质</strong>（整数二分）是在一个区别上有某个性质，一边满足一边不满足，那就可以通过二分将这个性质区分出来，即将这个边界点区分出来</p><h2 id="2-实现方法">2. 实现方法</h2><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230910182511542.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>算法模板：</p></li></ul><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">bool check(int x) {/* ... */} // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r){    while (l < r)    {        int mid = l + r >> 1;        if (check(mid)) r = mid;    // check()判断mid是否满足性质        else l = mid + 1;    }    return l;}// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r){    while (l < r)    {        int mid = l + r + 1 >> 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    return l;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-注意事项">3. 注意事项</h2><ol><li class="lvl-3"><p><strong><u>浮点数二分</u><strong>可以</strong>不考虑</strong><mark>边界</mark>，因为其有严格的<code>mid</code>。</p></li><li class="lvl-3"><p><strong><u>整数二分</u><strong>需要</strong>考虑</strong><mark>边界</mark>，例如：当判断结果为<code>true</code>，<code>l = mid</code>时，<code>mid = (l+r+1) &gt;&gt; 1</code>；当判断结果为<code>true</code>，<code>r = mid</code>时，<code>mid = (l+r) &gt;&gt; 1</code>。</p></li><li class="lvl-3"><p>二分法必有解，循环后结束条件为<code>l=r</code>，若题目无解，则是对解出来的值<code>l</code>进行相关的位置判断；位置正确，则题目有解；位置错误，则题目无解。但是<mark>二分法必有解<code>l=r</code></mark>；参考题目：<a href="https://www.acwing.com/problem/content/791/">789. 数的范围 - AcWing题库</a>。</p></li><li class="lvl-3"><p>二分法模板1<code>bsearch_1</code>找到的是==<strong>左边界</strong><mark>，模板2<code>bsearch_2</code>找到的是</mark><strong>右边界</strong>==，参考题目：<a href="https://www.acwing.com/problem/content/791/">789. 数的范围 - AcWing题库。</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——归并排序</title>
      <link href="/20230914/ji-chu-suan-fa-gui-bing-pai-xu/"/>
      <url>/20230914/ji-chu-suan-fa-gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1>归并排序</h1><h2 id="1-基本思想">1. 基本思想</h2><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230908093236112.png" alt="image-20230908093236112"><p>基本流程：</p><ol><li class="lvl-3"><p>确定分界点</p></li><li class="lvl-3"><p>递归排序<code>left</code>,<code>right</code></p></li><li class="lvl-3"><p><strong>归并</strong>——合二为一（重点）</p></li></ol><h2 id="2-实现方法">2. 实现方法</h2><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230908093507542.png" alt="image-20230908093507542"></p><ul class="lvl-0"><li class="lvl-2"><p><strong>双路归并，合二为一</strong></p></li><li class="lvl-2"><p>时间复杂度为<code>o(n)</code></p></li></ul><p>算法思想：</p><ol><li class="lvl-3"><p>先把左边排好序，再把右边排好序</p></li><li class="lvl-3"><p>用<code>i</code>,<code>j</code>分别指向数组1和数组2</p></li><li class="lvl-3"><p>比较<code>i</code>,<code>j</code>指向的数据，若<code>i</code>中的数据小于<code>j</code>中的数据，则将<code>i</code>中的数据取出放到<code>tmp[]</code>数组中，<code>i++</code></p></li><li class="lvl-3"><p>继续比较，直到某一指针指向其所对应的数组末尾，则将另一指针后面的所有的数直接拿到<code>tmp[]</code>数组的末尾</p></li><li class="lvl-3"><p>再将<code>tmp[]</code>数组中的数放回至想要存放数据的数组中</p></li></ol><p>算法模板：</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void merge_sort(int q[], int l, int r){    if (l >= r) return;    int mid = l + r >> 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i <= mid && j <= r)        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i <= mid) tmp[k ++ ] = q[i ++ ];    while (j <= r) tmp[k ++ ] = q[j ++ ];    /*    自己第一遍写写成这样了，多了一些if这种很没必要的判断    if (i == mid+1)        while(j <= r)  tmp[k++] = q[j++];    else if (j == r+1)        while(i <= mid)  tmp[k++] = q[i++];    */    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>个人觉得可以将k从l起开始赋值，写成以下形式,最后一步for循环的赋值或许会更简便一点</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void merge_sort(int q[], int l, int r){    if (l >= r) return;    int mid = l + r >> 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = l, i = l, j = mid + 1;    while (i <= mid && j <= r)        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i <= mid) tmp[k ++ ] = q[i ++ ];    while (j <= r) tmp[k ++ ] = q[j ++ ];    for (i = l; i <= r; ++i) q[i] = tmp[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——快速排序</title>
      <link href="/20230914/ji-chu-suan-fa-kuai-su-pai-xu/"/>
      <url>/20230914/ji-chu-suan-fa-kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1>快速排序</h1><h2 id="1-基本思想">1. 基本思想</h2><p>先分完，再递归两边</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230907202747523.png" alt="image-20230907202747523"></p><p>流程：</p><ol><li class="lvl-3"><p>确定分界点</p></li><li class="lvl-3"><p>调整区间（<u>最重要且最难的部分</u>）</p></li><li class="lvl-3"><p>递归处理左右两段</p></li></ol><h2 id="2-第二步调整区间的方法">2. 第二步调整区间的方法</h2><h3 id="2-1-暴力做法">2.1 暴力做法</h3><p>平均时间复杂度仍为<code>o(n)</code></p><ul class="lvl-0"><li class="lvl-2"><p>优点：思想简单</p></li><li class="lvl-2"><p>缺点：耗时为2n，不够快捷不够优美</p></li></ul><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes/algorithm/image-20230907203322166.png" alt="image-20230907203322166"></p><h3 id="2-2-快排">2.2 快排</h3><ol><li class="lvl-3"><p>最左端、最右端分别确定一个指针<code>i</code>、<code>j</code>（目标：指针<code>i</code>左边的值全都小于等于分界点，指针<code>j</code>右边的值全都大于等于分界点）</p></li><li class="lvl-3"><p>指针<code>i</code>,<code>j</code>分别往中间走；当<code>i</code>遇到一个大于等于分界点的点，则停下；当<code>j</code>遇到一个小于等于分界点的点，则停下；</p></li><li class="lvl-3"><p>当<code>i</code>,<code>j</code>都停下后，交换双方互相所指的值，然后继续往中间走，直至相遇。</p></li></ol><p>代码图例如下：</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">251923假定中间值取末尾值3则：2(i)51923(j)25(i)1923(j)//3<=3，j不动23(i)1925(j)//交换i、j所指的值231(i)92(j)52319(i)2(j)5//2<=3，j不动2312(i)9(j)5//交换i、j所指的值//则现在i左边的值全都小于等于3，j右边的值全都大于等于3//再分别对左右两边递归排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码如下:</p><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">void quick_sort(int q[], int l, int r){    if (l >= r) return;    int i = l - 1, j = r + 1, x = q[l + r >> 1];    while (i < j)    {        do i ++ ; while (q[i] < x);        do j -- ; while (q[j] > x);        if (i < j) swap(q[i], q[j]);    }    quick_sort(q, l, j), quick_sort(q, j + 1, r);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-一些要点">3. 一些要点</h2><h3 id="3-1-快排边界问题">3.1 快排边界问题</h3><p>边界问题参考<code>AcWing</code>上一篇文章，链接附下</p><blockquote><p>原文链接：<a href="https://www.acwing.com/solution/content/16777/">AcWing 785. 快速排序算法的证明与边界分析 - AcWing</a></p></blockquote><h3 id="3-2-其他">3.2 其他</h3><ul class="lvl-0"><li class="lvl-2"><p>快排中间点尽量取到中点才能保证算法的效率与时间复杂度接近<code>o(n)</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法——快速读写</title>
      <link href="/20230914/ji-chu-suan-fa-kuai-su-du-xie/"/>
      <url>/20230914/ji-chu-suan-fa-kuai-su-du-xie/</url>
      
        <content type="html"><![CDATA[<h1>快速读写(以C语言为例)</h1><p><strong>参考：<a href="https://www.luogu.com.cn/blog/cicos/fread-more">快读攻略（详） - 学委 的博客 - 洛谷博客 (luogu.com.cn)</a></strong></p><blockquote><p>C语言原本的输入输出函数<code>scanf</code>、<code>printf</code>由于考虑了很多复杂情况（例如①格式化字符串解析②错误处理③缓冲区刷新等），导致在读写位数较大的数据时速度较慢，故自己写一些速读、速写函数增加特定程序的运行速度</p></blockquote><h2 id="1-快读">1. 快读</h2><h3 id="1-1-快读原理">1.1 快读原理</h3><ul class="lvl-0"><li class="lvl-2"><p>数字之间用<code>空格</code>或者<code>换行符</code>来分隔。</p></li><li class="lvl-2"><p>关于负数，负号后面是它的绝对值。</p></li><li class="lvl-2"><p>由于数字正向给出，所以要读入 256 可以这样：</p><ul class="lvl-2"><li class="lvl-4">读入 2，记录 2。</li><li class="lvl-4">读入 5，先把之前的记录乘以 10，然后加上 5。现在记录了 25。</li><li class="lvl-4">读入 6，先把之前的记录乘以 10，然后加上 6。现在记录了 256。</li><li class="lvl-4">读到空格、换行符或者 EOF（读不到东西），就可以返回结果：256。</li></ul></li><li class="lvl-2"><p>我们用 <code>getchar()</code> 逐个读进<strong>数字字符</strong>，再<strong>减去字符 ‘0’</strong>(ASCII码为 48) 即得对应的数字。</p></li></ul><h3 id="1-2-基础实现">1.2 基础实现</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <stdio>#include <cctype>int getint(){    int res = 0, neg = 0, ch = getchar();    while(!(isdigit(ch) or ch == '-') and ch != EOF)        ch = getchar();    if(ch == '-')        neg = 1, ch = getchar();    while( isdigit(ch) )        res = res * 10 + (ch - '0'), ch = getchar();    return neg ? -res : res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序分析：现在该段程序对时间复杂度影响最大的为<code>getchar()</code>函数</p><h3 id="1-3-利用fread优化普通快读（优化getchar-函数）">1.3 利用<code>fread</code>优化普通快读（优化<code>getchar()</code>函数）</h3><h4 id="1-3-1-fread-函数详解">1.3.1 <code>fread()</code>函数详解</h4><pre class="line-numbers language-language-c"><code class="language-language-c">size_t fread(void *ptr, size_t size, size_t count, FILE *stream);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>fread</code>函数的作用是从指定的文件流 <code>stream</code> 中读取数据，并将读取的数据存储到 <code>ptr</code> 指向的内存块中。它的参数含义如下：</p><ul class="lvl-0"><li class="lvl-2"><p><code>ptr</code>：指向存储读取数据的内存块的指针。</p></li><li class="lvl-2"><p><code>size</code>：每个元素的大小（字节数）。</p></li><li class="lvl-2"><p><code>count</code>：要读取的元素个数。</p></li><li class="lvl-2"><p><code>stream</code>：要读取数据的文件流。</p></li></ul><h4 id="1-3-2-利用fread-函数替代基础实现中的getchar-函数">1.3.2 利用<code>fread()</code>函数替代基础实现中的<code>getchar()</code>函数</h4><pre class="line-numbers language-language-c"><code class="language-language-c">#include <stdio.h>#define BUFSIZE (1 << 20) // 1048576char tmp[BUFSIZE];int cnt = 0, Max = 0;char getch(){    if (cnt == Max)//第一次输入的情况    {        cnt = 0;        Max = fread(tmp, 1, BUFSIZE, stdin);    }    return tmp[cnt++];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-3-嵌入getch-的指针写法快读">1.3.3 嵌入<code>getch()</code>的指针写法快读</h4><pre class="line-numbers language-language-c"><code class="language-language-c">#include <stdio.h>#include <ctype.h>#define BUFSIZE (1 << 20)char ibuf[BUFSIZE], *is = *ibuf[0], *it = *ibuf[0];char getch() {    if (is == it) {        it = (is = ibuf) + fread(ibuf, 1, BUFSIZE, stdin);    }    return (is == it) ? EOF : *is++;}int getint() {    int res = 0;    int neg = 0;    int ch = getch();        while (!(isdigit(ch) || ch == '-') && ch != EOF) {        ch = getch();    }    if (ch == '-') {        neg = 1;        ch = getch();    }    while (isdigit(ch)) {        res = res * 10 + (ch - '0');        ch = getch();    }    return neg ? -res : res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><u>编译运行、键盘输入数据时 <code>fread()</code> 无法停止？因为它期望得到太多字符，键盘输入时它不知道什么时候是末尾，所以你得告诉它“已经结束输入”。<strong>按 <code>Ctrl + Z</code> 后再回车就好了。</strong></u></p><h2 id="2-快输">2. 快输</h2><h3 id="2-1-快输原理">2.1 快输原理</h3><ul class="lvl-0"><li class="lvl-2"><p>关于负数，在负号后方输出绝对值。</p></li><li class="lvl-2"><p>正向输出一个数字。通过模 10 的方式我们可以直接获得它的最后一位，然后整个数除以 10 <strong>使原来最后第二位变成最后一位。<strong>但是注意这是获取了最后一位，因此不能直接逐位输出，要</strong>暂存后倒序输出</strong>。</p></li><li class="lvl-2"><p>第2步中，我们不断循环获取最后一位，退出条件是当前数剩余 0，所以，如果开始时这个数就是 0，就要<strong>特判后输出一个 0</strong>。0 确实是一个特殊的数，人为规定了用一个字符表示它。</p></li><li class="lvl-2"><p>用 <code>putchar()</code> 逐位输出数字。要输出的是数字字符，而我们模 10 后得到的是数，因此输出时要加上字符 ‘0’(或 48)。“当同一行中有多于一个元素时，须用单个空格符以作分隔。”</p></li><li class="lvl-2"><p>间隔符号，如空格、换行，要另外输出。</p></li></ul><h3 id="2-2-基础实现">2.2 基础实现</h3><pre class="line-numbers language-language-c"><code class="language-language-c">inline void putint(int res){    char q[10];        if(res == 0)        putchar('0');    else    if(res < 0)    {        putchar('-');        res = -res;    }        int top = 0;    while(res)    {        q[top++] = res % 10 + '0';        res /= 10;    }    while(top--)        putchar(q[top]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-利用fwrite优化普通快输（优化putchar-函数）">2.3 利用<code>fwrite</code>优化普通快输（优化<code>putchar()</code>函数）</h3><h4 id="2-3-1-fwrite-函数详解">2.3.1 <code>fwrite()</code>函数详解</h4><pre class="line-numbers language-language-c"><code class="language-language-c">size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>fwrite</code>函数接受四个参数：</p><ul class="lvl-0"><li class="lvl-2"><p><code>ptr</code>：指向要写入数据的内存块的指针。</p></li><li class="lvl-2"><p><code>size</code>：要写入的每个数据项的大小（以字节为单位）。</p></li><li class="lvl-2"><p><code>count</code>：要写入的数据项的数量。</p></li><li class="lvl-2"><p><code>stream</code>：指向目标文件的指针。</p></li></ul><p><code>fwrite</code>函数将<code>count</code>个数据项（每个大小为<code>size</code>字节）从<code>ptr</code>指向的内存块写入到由<code>stream</code>指向的文件中。它返回成功写入的数据项数量。如果返回的数量与<code>count</code>不一致，可能表示写入过程中发生了错误。</p><h4 id="2-3-2-利用fwrite-函数替代基础实现中的putchar-函数">2.3.2 利用<code>fwrite()</code>函数替代基础实现中的<code>putchar()</code>函数</h4><pre class="line-numbers language-language-c"><code class="language-language-c">#include <stdio.h>#define BUFSIZE (1 << 20)char tmp[BUFSIZE];int cnt = 0;void flush(){    fwrite(tmp, 1, cnt, stdout);    cnt = 0;}void putch(char ch){    tmp[cnt++] = ch;    if (cnt == BUFSIZE)        flush();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK R98键盘使用说明(自用)</title>
      <link href="/20230822/rk-r98-jian-pan-shi-yong-shuo-ming-zi-yong/"/>
      <url>/20230822/rk-r98-jian-pan-shi-yong-shuo-ming-zi-yong/</url>
      
        <content type="html"><![CDATA[<h1>RK  R98键盘使用说明（自用）</h1><p>最近买了个RK R98 TTC钢铁轴的键盘，有些快捷键用markdown记录下来直接在博客上找，免得到处翻，比较方便</p><h2 id="1-指示灯功能">1. 指示灯功能</h2><p>从左至右依次为Num Lock、Caps Lock、WIN Lock<br><mark>充电时常亮；充满后熄灭；低电量时闪烁</mark></p><h2 id="2-第二组合键功能">2. 第二组合键功能</h2><table><thead><tr><th>按键</th><th>按键功能</th></tr></thead><tbody><tr><td>Fn + A</td><td>切换到windows系统</td></tr><tr><td>Fn + S</td><td>切换到mac系统</td></tr><tr><td>Fn + Ins</td><td>ScrLK</td></tr><tr><td>Fn + PrtSc</td><td>Home</td></tr><tr><td>Fn + PgUp</td><td>Pause</td></tr><tr><td>Fn + PgDn</td><td>End</td></tr></tbody></table><h2 id="3-电池电量提示">3. 电池电量提示</h2><p>按<code>Fn + ENTER</code>查看电池电量情况，根据数字键1~0亮的个数显示电量剩余百分数</p><h2 id="4-BlueTeeth连接">4. BlueTeeth连接</h2><blockquote><p>蓝牙配对方法：<br>1.开关拨到B状态。<br>2.FN+Q/W/E.任意一组长按3秒对码，比如Fn+Q，此时Q键持续闪烁，表示已进入配对状态，慢闪烁表示键盘在回连状态。<br>3.打开电脑/手机蓝牙，搜索并连接设备，搜索显示的名称：R98RGB 3.0（连接PC端Windows7以下系统），R98RGB 5.0(连接Windows8以上系统版本，移动设备等）。<br>4.完成连接以此类推：重复以上步骤，Q/W/E可存储3组蓝牙设备，在使用切换时短按Fn+Q/W/E，即可在不同蓝牙设备之间切换（温馨提示：使用切换前，请先配对好3组蓝牙）</p></blockquote><h2 id="5-2-4G连接">5. 2.4G连接</h2><blockquote><p>2.4G配对方法：开关拨到G状态。FN+P长按对码，P键闪烁插入接收器，P键停止闪烁即对码成功。慢闪烁表示键盘在回连状态。（温馨提示：出厂时已配对好接收器，无需再次配对）</p></blockquote><h2 id="6-背光控制">6. 背光控制</h2><table><thead><tr><th style="text-align:left">按键</th><th style="text-align:left">功能</th><th>按键</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:left">Fn + ↑</td><td style="text-align:left">字健背光亮度+</td><td>Fn + win</td><td>窗口锁定</td></tr><tr><td style="text-align:left">Fn + ↓</td><td style="text-align:left">字健背光亮度-</td><td>Fn + <code>— _</code></td><td>侧边灯切换</td></tr><tr><td style="text-align:left">Fn + ←</td><td style="text-align:left">动态背光速度-</td><td>Fn + <code>\ </code></td><td>背光效果切换</td></tr><tr><td style="text-align:left">Fn + →</td><td style="text-align:left">动态背光速度+</td><td>Fn + <code>Space</code></td><td>长按三秒，恢复出厂设置</td></tr><tr><td style="text-align:left">Fn + +</td><td style="text-align:left">灯条亮度+</td><td>Fn + <code>, &lt;</code></td><td>切换背光颜色</td></tr><tr><td style="text-align:left">Fn + -</td><td style="text-align:left">灯条亮度-</td><td>Fn + <code>= +</code></td><td>切换灯条颜色</td></tr><tr><td style="text-align:left">Fn + Esc</td><td style="text-align:left">关闭所有灯光</td><td></td><td></td></tr></tbody></table><h2 id="7-背光录制方法">7. 背光录制方法</h2><ol><li class="lvl-3"><p>按<code>Fn + 1!</code>选择要自定义的背光注：<code>Fn + 2@</code>和<code>Fn + 3#</code>为固定灯效，不可录制</p></li><li class="lvl-3"><p>按<code>Fn + ←Backspace</code>进入背光录制模式</p></li><li class="lvl-3"><p>按下想要录制背光的按键，重复此步骤，录制自己想要的背光</p></li><li class="lvl-3"><p>完成后，再次按下<code>Fn + Back</code>，将保存并推出背光录制模式</p></li></ol><h2 id="8-WINDOWS多媒体键">8. WINDOWS多媒体键</h2><table><thead><tr><th>按键</th><th>功能</th><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>Fn + F1</td><td>我的电脑</td><td>Fn + F7</td><td>上一曲</td></tr><tr><td>Fn + F2</td><td>浏览器</td><td>Fn + F8</td><td>播放/暂停</td></tr><tr><td>Fn + F3</td><td>邮箱</td><td>Fn + F9</td><td>下一曲</td></tr><tr><td>Fn + F4</td><td>计算器</td><td>Fn + F10</td><td>静音</td></tr><tr><td>Fn + F5</td><td>播放器</td><td>Fn + F11</td><td>音量减</td></tr><tr><td>Fn + F6</td><td>停止</td><td>Fn + F12</td><td>音量加</td></tr></tbody></table><h2 id="9-MAC多媒体键">9. MAC多媒体键</h2><p>MAC系统（FN + s：切换到MAC系统）MAC系统视窗键和ALT键互换</p><table><thead><tr><th>按键</th><th>功能</th><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>Fn + F1</td><td>屏幕亮度减小</td><td>Fn + F8</td><td>播放/暂停</td></tr><tr><td>Fn + F2</td><td>屏幕亮度增加</td><td>Fn + F9</td><td>下一曲</td></tr><tr><td>Fn + F5</td><td>键盘背光亮度减小</td><td>Fn + F10</td><td>静音</td></tr><tr><td>Fn + F6</td><td>键盘背光亮度增加</td><td>Fn + F11</td><td>音量减</td></tr><tr><td>Fn + F7</td><td>上一曲</td><td>Fn + F12</td><td>音量加</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows常用快捷键</title>
      <link href="/20230819/windows-chang-yong-kuai-jie-jian/"/>
      <url>/20230819/windows-chang-yong-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h1>WINDOWS常用快捷键（自用）</h1><h2 id="Alt系列">Alt系列</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Alt + Enter/<br>Alt + 鼠标左键双击</td><td>显示所选项目的属性</td></tr><tr><td>Alt + 空格键</td><td>打开活动窗口的快捷菜单</td></tr><tr><td>Alt + 向左键</td><td>返回</td></tr><tr><td>Alt + 向右键</td><td>前进</td></tr><tr><td>Alt + 向上键</td><td>查看该文件夹所在的文件夹</td></tr><tr><td>Alt + Page Up</td><td>向上移动一个屏幕</td></tr><tr><td>Alt + Page     Down</td><td>向下移动一个屏幕</td></tr><tr><td>Alt + F8</td><td>在登录屏幕上显示你的密码</td></tr><tr><td>Alt + D</td><td>选择地址栏</td></tr><tr><td>Alt + Esc</td><td>按项目打开顺序循环浏览</td></tr><tr><td>Alt + F4</td><td>关闭活动项，或者退出活动应用</td></tr><tr><td>Alt + Tab</td><td>在打开的应用之间切换（向前切换）</td></tr><tr><td>Alt + Shift + Tab</td><td>在打开的应用之间切换（向后切换）</td></tr></tbody></table><h2 id="Ctrl系列">Ctrl系列</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl +  Tab</td><td>在选项卡中向前移动</td></tr><tr><td>Ctrl + Shift + Tab</td><td>在选项卡中向后移动</td></tr><tr><td>Ctrl + (数字 1–9)</td><td>移动到第  n 个选项卡</td></tr><tr><td>Ctrl + 鼠标左键</td><td>逐个选择多个项目</td></tr><tr><td>Shift + 鼠标左键</td><td>连续选择多个项目</td></tr><tr><td>Ctrl + Shift + Esc</td><td>打开任务管理器</td></tr><tr><td>Ctrl + F</td><td>选择搜索框</td></tr><tr><td>Ctrl + N</td><td>打开新窗口</td></tr><tr><td>Ctrl + W</td><td>关闭活动窗口</td></tr><tr><td>Ctrl + 鼠标滚轮</td><td>更改文件和文件夹图标的大小和外观</td></tr><tr><td>Ctrl + E</td><td>选择搜索框</td></tr><tr><td>Ctrl + Shift + N</td><td>新建文件夹</td></tr><tr><td>Ctrl + Shift + Win + B</td><td>重启显卡驱动程序，有助于解决显示问题，如图像冻结、黑屏等</td></tr><tr><td>Ctrl + A</td><td>选择文档或窗口中的所有项目</td></tr><tr><td>Ctrl + X</td><td>剪切选定项</td></tr><tr><td>Ctrl + Z</td><td>撤消操作</td></tr><tr><td>Ctrl + Shift + Z     （或Ctrl + Y）</td><td>恢复操作</td></tr><tr><td>Ctrl + R（或 F5）</td><td>刷新活动窗口</td></tr><tr><td>Ctrl + D（或 Delete）</td><td>删除选定项，将其移至回收站</td></tr><tr><td>Shift + Delete</td><td>删除选定项，无需先移动到回收站</td></tr><tr><td>Ctrl + C（或 Ctrl + Insert）</td><td>复制选定项</td></tr><tr><td>Ctrl + V（或 Shift + Insert）</td><td>粘贴选定项</td></tr><tr><td>Ctrl + →</td><td>将光标移动到下一个字词的起始处</td></tr><tr><td>Ctrl + ←</td><td>将光标移动到上一个字词的起始处</td></tr><tr><td>Ctrl + ↓</td><td>将光标移动到下一段落的起始处</td></tr><tr><td>Ctrl + ↑</td><td>将光标移动到上一段落的起始处</td></tr><tr><td>Ctrl + Alt + Tab</td><td>使用箭头键在所有打开的应用之间进行切换</td></tr><tr><td>Ctrl + F4</td><td>关闭活动文档（在可全屏显示并允许你同时打开多个文档的应用中）</td></tr></tbody></table><h2 id="Win系列">Win系列</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Win +  D</td><td>显示和隐藏桌面</td></tr><tr><td>Win + M</td><td>最小化所有窗口</td></tr><tr><td>Win + ↑</td><td>最大化窗口</td></tr><tr><td>Win + ↓</td><td>将当前应用从屏幕上移除或最小化桌面窗口</td></tr><tr><td>Win + ←</td><td>最大化屏幕左侧的应用或桌面窗口</td></tr><tr><td>Win + →</td><td>最大化屏幕右侧的应用或桌面窗口</td></tr><tr><td>Win + L</td><td>锁定你的电脑</td></tr><tr><td>Win‌ +  Ctrl + Shift + B</td><td>从空白或黑屏唤醒电脑</td></tr><tr><td>Win + Ctrl + D</td><td>添加虚拟桌面</td></tr><tr><td>Win + Ctrl + 向右键</td><td>在你于右侧创建的虚拟桌面之间切换</td></tr><tr><td>Win + Ctrl + 向左键</td><td>在你于左侧创建的虚拟桌面之间切换</td></tr><tr><td>Win + Ctrl + F4</td><td>关闭你正在使用的虚拟桌面</td></tr><tr><td>Win +  E</td><td>打开文件资源管理器</td></tr><tr><td>Win + V</td><td>打开剪贴板。</td></tr><tr><td>Win + R</td><td>打开“运行”对话框</td></tr><tr><td>Win + A</td><td>打开操作中心</td></tr><tr><td>Win + K</td><td>打开“连接”快速操作</td></tr><tr><td>Win +  I</td><td>打开设置</td></tr><tr><td>Win + P</td><td>打开投影、屏幕连接</td></tr><tr><td>Win + S</td><td>打开搜素</td></tr><tr><td>Win + U</td><td>打开轻松使用设置中心</td></tr><tr><td>Win + X</td><td>打开“快速链接”菜单</td></tr><tr><td>Win + 句号 (.) /分号 (😉</td><td>打开表情符号面板</td></tr></tbody></table><h2 id="其他">其他</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Tab</td><td>在选项中向前移动</td></tr><tr><td>Shift + Tab</td><td>在选项中向后移动</td></tr><tr><td>F6</td><td>循环浏览窗口中或桌面上的屏幕元素</td></tr><tr><td>F2</td><td>重命名所选项目</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX格式截图</title>
      <link href="/20230813/latex-ge-shi-jie-tu/"/>
      <url>/20230813/latex-ge-shi-jie-tu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2FLaTeX%2F1.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2FLaTeX%2F2.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2FLaTeX%2F3.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2FLaTeX%2F4.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2FLaTeX%2F5.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2FLaTeX%2F6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必备工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB学习笔记</title>
      <link href="/20230813/matlab-xue-xi-bi-ji/"/>
      <url>/20230813/matlab-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1>MATlAB学习笔记</h1><p>数学模型四大组成部分：</p><ul class="lvl-0"><li class="lvl-2"><p>决策变量（自变量）</p></li><li class="lvl-2"><p>环境变量（无法干预的因素）</p></li><li class="lvl-2"><p>目标函数（因变量）</p></li><li class="lvl-2"><p>约束条件（可行域的范围）</p></li></ul><p>物理模型（事物模型）、符号模型、数学模型</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F1.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F2.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F3.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F4.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F5.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F6.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F7.png" alt=""></p><h2 id="数学建模竞赛论文写作规范">数学建模竞赛论文写作规范</h2><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F8.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F9.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F10.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F11.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F12.png" alt=""></p><h2 id="MATLAB皮毛">MATLAB皮毛</h2><h3 id="1-变量">1.变量</h3><p>变量名区别大小写</p><p>字母开头（可使用字母、数字、下划线），最多不超多63位</p><p>clear all 清除右侧工作区变量</p><p>clc清除命令行所有内容</p><p>注释“%% ”</p><h4 id="1-1数字">1.1数字</h4><h4 id="1-2字符和字符串">1.2字符和字符串</h4><p>s = ‘a’</p><p>abs(s)=97</p><p>char(97) = ‘a’</p><h4 id="1-3矩阵">1.3矩阵</h4><p>A = [1 2 3; 4 5 2; 6 7 2] 或者A=[1,2,3; 4,5,2; 6,7,2]</p><p>分号 ‘;’ 跳到下一行，逗号 ‘,’ 和空格 ’ ’ 分开数字</p><p>B = A’——B为A的转置</p><p>C = A(😃——竖着拉长</p><p>D = inv(A)——矩阵求逆（非方阵无法求逆）</p><p>A * D</p><p>E = zeros(10,5,3)——三维10行5列矩阵</p><p><mark>rand</mark></p><p>rand(m,n)生成m行n列的均匀分布的伪随机数</p><p>rand(m,n,‘double’)生成指定精度的均匀分布的伪随机数，参数还可以是’single’</p><p><mark>randi</mark></p><p>randi(iMax)在开区间(0,iMax)生成均匀分布的伪随机整数</p><p>randi(iMax,m,n)在开区间(0,iMax)生成m*n型随机矩阵</p><p>r = randi([iMin,iMax], m, n)也是开区间</p><p><mark>randn</mark></p><p>生成标准分布的伪随机数（均值为0，方差为1）</p><h4 id="1-4元胞数组">1.4元胞数组</h4><p>A = <mark>cell</mark>(1,6)——1行6列的元胞数组</p><p>A{2} = <mark>eye</mark>(3)——A{2}为3*3的对角线数值为1的单位矩阵</p><p>A{5} =<mark> magic</mark>(3)——生成一个3阶的幻方。3阶幻方就是1-9九个数字，组成一个3*3的矩阵，使得该矩阵无论横、竖、斜三个方向的数的和相等。</p><ul class="lvl-0"><li class="lvl-2"><p>magic(n)——生成一个n阶的幻方。n阶幻方就是1-n^2个数字，组成一个n*n的矩阵，使得该矩阵无论横、竖、斜三个方向的数的和相等，和为n * (n^2+1) / 2</p></li><li class="lvl-2"></li></ul><h4 id="1-5结构体">1.5结构体</h4><p><code>books = &lt;mark&gt;struct&lt;/mark&gt;('name' , {{'Machine Learning' , 'Data Mining'}} , 'price' , [30 , 40])</code></p><p><a href="http://books.name">books.name</a> = {‘Machine Learning’}    {‘Data Mining’}</p><p><a href="http://books.name">books.name</a>(1) = {‘Machine Learning’}——取出来的是cell</p><p><a href="http://books.name">books.name</a>{1} = ‘Machine Learning’——取出来的是字符串</p><h3 id="2-矩阵操作">2.矩阵操作</h3><h4 id="2-1矩阵的定义和构造">2.1矩阵的定义和构造</h4><p>A = [1 2 16 1 03 16]</p><p>B = 0 : 2 : 10——B = [ 0  2  4  6  8  10 ]，从0到10，2为步长</p><p>C = <mark>repmat</mark>(B, 3, 1)</p><p>C =</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 0     2     4     6     8    10 0     2     4     6     8    10 0     2     4     6     8    10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>C = repmat(B, 3, 2)——把B重复3行2列</p><p>C =</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 0     2     4     6     8    10     0     2     4     6     8    10 0     2     4     6     8    10     0     2     4     6     8    10 0     2     4     6     8    10     0     2     4     6     8    10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>D = <mark>ones</mark>(3,2)</p><p>D =</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 1     1 1     1 1     1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-2矩阵的四则运算">2.2矩阵的四则运算</h4><p>A = [1 2 3 4; 5 6 7 8]</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 1     2     3     4 5     6     7     8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>B = [9 9 6 6; 7 7 8 8]</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 9     9     6     6 7     7     8     8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>C = A+B</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">10    11     9    1012    13    15    16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>D = A-B</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">-8    -7    -3    -2-2    -1    -1     0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>E = A * B’——A乘B的转置</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">69    77189&nbsp;&nbsp;&nbsp;197<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>F = A .* B——对应项相乘</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 9    18    18    2435    42    56    64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>G = <mark>A / B</mark>——相当于A乘于B的逆，<mark>A * pinv(B)</mark></p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">-0.4167    0.7500-0.2833    1.1500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>H = A ./ B——对应项相除</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">0.1111    0.2222    0.5000    0.66670.7143    0.8571    0.8750    1.0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-3矩阵的下标">2.3矩阵的下标</h4><p>A =magic(5)</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">17    24     1     8    1523     5     7    14    16 4     6    13    20    2210    12    19    21     311    18    25     2     9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B =A(2,3)</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>C =A(3,:)</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 4     6    13    20    22<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>D =A(:,4)</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 8142021 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark>[m , n] = find(A &gt; 20)</mark></p><p>m =</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 2 1 5 4 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>n =</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab"> 1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-MATLAB的逻辑和流程控制">3.MATLAB的逻辑和流程控制</h3><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">if        else    endfor       endwhile     endswitch    case    end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1for循环结构">3.1for循环结构</h4><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F13.png" alt=""></p><p>步长默认为1,可以省略</p><h4 id="3-2while循环结构">3.2while循环结构</h4><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F14.png" alt=""></p><h4 id="3-3if…else…end结构">3.3if…else…end结构</h4><h4 id="3-4switch…case…end结构">3.4switch…case…end结构</h4><h3 id="4-MATLAB基本绘图操作">4.MATLAB基本绘图操作</h3><h4 id="4-1二维平面绘图">4.1二维平面绘图</h4><p><mark>figure</mark>建立一个幕布</p><p><mark>plot(x,y)</mark>——以x为横轴，y为纵轴建立一个坐标系</p><p><mark>title( ‘y=sin(x)’ )</mark>——给图像标题命名</p><p><mark>xlable(‘x’)</mark>——x轴标签</p><p><mark>ylable(‘sin(x)’)</mark>——y轴标签</p><p><mark>xlim([0 2*pi])</mark>——将图像中的x轴坐标范围限定在[0,2*pi]之间</p><p>参数：</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F15.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F16.png" alt=""></p><p>对同一个幕布同一个x有多个y：</p><ul class="lvl-0"><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4"><mark>plotyy(x,y1,x,y2,‘plot’)</mark></li></ul></li></ul><h4 id="4-2三维立体绘图">4.2三维立体绘图</h4><p><mark>plot3</mark>(x,sin(x),cos(x))</p><p><mark>hold on</mark>——在同一个幕布当中绘制多条线</p><p><mark>hold off</mark>——不保存多个东西</p><p><mark>grid on</mark>——在图后面加一些网格线</p><h3 id="5-MATLBA图形的保存与导出">5.MATLBA图形的保存与导出</h3><h2 id="MATLAB数学建模">MATLAB数学建模</h2><p>（以《MATLAB数学建模》——李昕版本为参考书籍）</p><h3 id="第一章-MATLAB基础知识">第一章 MATLAB基础知识</h3><h4 id="1-1-数组和变量">1.1 数组和变量</h4><h4 id="1-1-1-数组的定义">1.1.1 数组的定义</h4><h4 id="1-1-2-数组的创建">1.1.2 数组的创建</h4><p>1.创建空数组</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> A = []A =     []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.创建一维数组</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> A = [1 2 3]A =     1     2     3>> B = [1;2;3]B =     1     2     3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和冒号类似的功能是linspace函数：</p><ul class="lvl-0"><li class="lvl-2"><p>Var = <mark>linspace(start_var, stop_var, n)</mark>，从start_var到stop_var，创建总元素为n的等差数列，n默认值为100</p></li><li class="lvl-2"><p>Var = <mark>logspace(start_var, stop_var, n)</mark>，从10<sup>start_var到10</sup>stop_var，创建总元素为n的等比数列，n默认值为100</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> A = 1:4A =     1     2     3     4>> B = 1:2:4B =     1     3>> C = linspace(1,2,4)C =    1.0000    1.3333    1.6667    2.0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> logspace(0, log10(32), 6)ans =    1.0000    2.0000    4.0000    8.0000   16.0000   32.0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.创建二维数组</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> A = [1 2 3; 2 5 6; 1 4 5]A =     1     2     3     2     5     6     1     4     5>> B = [1:5; linspace(3,10,5); 3 5 2 6 4]B =    1.0000    2.0000    3.0000    4.0000    5.0000    3.0000    4.7500    6.5000    8.2500   10.0000    3.0000    5.0000    2.0000    6.0000    4.0000>> C = [[1:3]; [linspace(2,3,3)]; 3 5 6]C =    1.0000    2.0000    3.0000    2.0000    2.5000    3.0000    3.0000    5.0000    6.0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.创建三维数组</p><p>1）使用下标创建三维数组</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> for i = 1:2for j = 1:2for k = 1:2A(i,j,k) = i + j + k;endendend>> AA(:,:,1) =     3     4     4     5A(:,:,2) =     4     5     5     6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> B(3,4,:)=2:5B(:,:,1) =     0     0     0     0     0     0     0     0     0     0     0     2B(:,:,2) =     0     0     0     0     0     0     0     0     0     0     0     3B(:,:,3) =     0     0     0     0     0     0     0     0     0     0     0     4B(:,:,4) =     0     0     0     0     0     0     0     0     0     0     0     5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2)使用低维数组创建高维数组</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>>D2 = [1 2 3; 4 5 6; 7 8 9];D3(:,:,1) = D2;D4(:,:,2) = 2*D2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3)使用创建函数创建三维数组</p><ul class="lvl-0"><li class="lvl-2"><p>C = <mark>cat(dim,A1,A2,A3,···)</mark>，cat的功能是连接数组，dim是创建数组的维度，A1、A2、A3表示各维度上的数组</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> D1 = [ 1 2 3 ;4 5 6; 1 1 1]D2 = cat(3,2*D1,D1*D1,D1')D1 =     1     2     3     4     5     6     1     1     1D2(:,:,1) =     2     4     6     8    10    12     2     2     2D2(:,:,2) =    12    15    18    30    39    48     6     8    10D2(:,:,3) =     1     4     1     2     5     1     3     6     1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>repmat</mark>用来复制并堆砌数组</p></li><li class="lvl-2"><p><mark>reshape</mark>用来重构数组</p></li></ul><p>5.利用函数创建标准数组</p><ul class="lvl-0"><li class="lvl-2"><p><mark>zeros</mark></p></li><li class="lvl-2"><p><mark>ones</mark></p></li><li class="lvl-2"><p><mark>eye</mark>——单位矩阵</p></li><li class="lvl-2"><p><mark>magic</mark></p></li><li class="lvl-2"><p><mark>randn</mark></p></li><li class="lvl-2"><p><mark>gallery</mark>——测试矩阵</p></li></ul><h4 id="1-1-3-多维数组及其操作">1.1.3 多维数组及其操作</h4><p>1.属性</p><ul class="lvl-0"><li class="lvl-2"><p><mark>size(A)</mark>——返回数组每一维上的大小</p></li><li class="lvl-2"><p><mark>ndims(A)</mark>——返回数组A具有的维度值</p></li><li class="lvl-2"><p><mark>whos</mark>——返回当前工作区各个变量的详细信息</p></li></ul><p>2.维度操作</p><ul class="lvl-0"><li class="lvl-2"><p><mark>permute</mark>函数可以按照指定的顺序重新定义多维数组的维度顺序</p></li><li class="lvl-2"><p><mark>ipermute</mark>函数被看作permute的逆函数，当B=permute(A,dims)时，ipermute(B,dims)刚好返回多维数组A</p></li></ul><p>3.科学运算</p><ul class="lvl-0"><li class="lvl-2"><p><mark>sum</mark>、<mark>mean</mark>等函数可以对多维数组中第1个不为1的维度上的向量进行计算</p></li><li class="lvl-2"><p><mark>sin</mark>、<mark>cos</mark>则对每一个元素单独进行运算</p></li><li class="lvl-2"><p><mark>eigs</mark>等针对二维数组的运算函数则需要用指定的页面上的二维数组作为输入函数</p></li></ul><h4 id="1-2-矩阵">1.2 矩阵</h4><h4 id="1-2-1符号矩阵的生成">1.2.1符号矩阵的生成</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>str2sym</mark>——符号赋值函数</p></li><li class="lvl-2"><p><mark>syms</mark>——符号声明函数</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> sym_matrix = str2sym('[a b c; Jack Mike John]')sym_matrix =[   a,    b,    c][Jack, Mike, John]>> syms a b cM1 = sym('Classical')M2 = sym('Jazz')M3 = sym('Blues')syms_matrix = [a b c;M1,M2,M3;2,3 5]M1 =ClassicalM2 =JazzM3 =Bluessyms_matrix =[        a,    b,     c][Classical, Jazz, Blues][        2,    3,     5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-大矩阵的生成">1.2.2 大矩阵的生成</h4><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> M = [1 2 3 4 51 2 3 4 66 6 6 6 6 ]M =     1     2     3     4     5     1     2     3     4     6     6     6     6     6     6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-3-矩阵的数学函数">1.2.3 矩阵的数学函数</h4><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F17.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p><mark>exp(x)</mark>——计算矩阵x中每一个元素的指数</p></li><li class="lvl-2"><p><mark>expm(x)</mark>——对矩阵x求指数</p></li><li class="lvl-2"><p><mark>logm(x)</mark>——计算矩阵x的对数，是exmp函数的逆运算</p></li><li class="lvl-2"><p><mark>complex(a,b)</mark>——a+bi</p></li><li class="lvl-2"><p><mark>abs(3+2i)</mark>——求矩阵的模、求复数的幅值</p></li><li class="lvl-2"><p><mark>det(x)</mark>——计算方阵行列式的值</p></li><li class="lvl-2"><p><mark>eig(x)</mark>——求解方阵的特征值和特征向量</p></li><li class="lvl-2"><p><mark>inv(x)</mark>——求解方阵的逆矩阵</p></li></ul><h4 id="1-3-符号运算的基本内容">1.3 符号运算的基本内容</h4><h4 id="1-3-1-符号变量代换其函数">1.3.1 符号变量代换其函数</h4><p>subs(S, old, new)——将符号表达式S中的old变量替换为new</p><p>subs(S, new)——用new置换符号表达式S中的自变量</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> syms a b c d k n x y w t;f = a * x^n + b * y + k f1 = subs(f,[a b],[sin(t) log(w)])f2 = subs(f1,k,1:4)f =k + a*x^n + b*yf1 =k + x^n*sin(t) + y*log(w)f2 =[x^n*sin(t) + y*log(w) + 1, x^n*sin(t) + y*log(w) + 2, x^n*sin(t) + y*log(w) + 3, x^n*sin(t) + y*log(w) + 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-2-符号对象转换为数值对象的函数">1.3.2 符号对象转换为数值对象的函数</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>double©</mark>——将符号常量C转换为双精度值</p></li><li class="lvl-2"><p><mark>digits(D)</mark>——设置有效数字为D的近似解精度</p></li><li class="lvl-2"><p><mark>vpa(E,D)</mark>——求得符号表达式E的D位精度的数值解</p></li><li class="lvl-2"><p><mark>numeric(E)</mark>——将不含变量的符号表达式E转换为double双精度浮点数值形式，其效果与N = double(sym(E))相同</p></li></ul><h4 id="1-3-3-符号表达式的化简">1.3.3 符号表达式的化简</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>factor()</mark>——符号表达式因式分解</p></li><li class="lvl-2"><p><mark>expand()</mark>——符号表达式展开</p></li><li class="lvl-2"><p><mark>collect()</mark>——合并同类项</p></li><li class="lvl-2"><p><mark>simplify()</mark>——将符号表达式运用多种恒等变换综合化简</p></li><li class="lvl-2"><p><s>[R,HOW] = simple()——化简范围大于simplify，R为被化简的表达式，HOW为化简方法</s></p></li><li class="lvl-2"><p><mark>[N,D] = numden()</mark>——通分，返回通分后的分子N与分母D，并转换成分子分母都是整系数的最佳多项式形式。若无等号左边的输出参数时，仅返回通分后的分子N，即numden(E)左边无”[N,D]=“时，输出为N。</p></li><li class="lvl-2"><p><mark>horner()</mark>——将符号表达式转换为嵌套形式表达式</p></li></ul><h4 id="1-3-4-符号运算的其他函数">1.3.4 符号运算的其他函数</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>char()</mark>——将数值对象、符号对象转换为字符对象</p></li><li class="lvl-2"><p><mark>pretty()</mark>——以习惯的方式显示符号表达式</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> syms a b c d x yf = a * x/b + c/(d * y);f1 = sqrt(b^2 - 4*a*c);pretty(f)pretty(f1) c    a x--- + ---d y    b      2sqrt(b  - 4 a c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>clear</mark>——清除MATLBA工作区中的内容</p></li></ul><h4 id="1-3-5-两种特定的符号运算常数">1.3.5 两种特定的符号运算常数</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>compose()</mark>——复合函数运算命令</p></li><li class="lvl-2"><p><mark>finverse()</mark>——反函数运算命令</p></li></ul><h3 id="第二章-数学建模基础">第二章 数学建模基础</h3><h4 id="2-1-数学建模的概念">2.1 数学建模的概念</h4><h4 id="2-2-数据导入和保存">2.2 数据导入和保存</h4><p>1.数据导入——<mark>load</mark>、<mark>importdata</mark></p><p>2.文件的存储——<mark>save</mark></p><p>3.文件的打开——<mark>open</mark></p><p>注：open是以结构体的形式打开在工作区中</p><h4 id="2-3-数据统计和分析">2.3 数据统计和分析</h4><h4 id="2-3-1-常用统计量">2.3.1 常用统计量</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>mean()</mark>——求算数平均值</p><p>nanmean()——忽略NaN计算算数平均值</p></li><li class="lvl-2"><p><mark>median()</mark>——计算中位数</p><p>nanmedian()</p></li><li class="lvl-2"><p><mark>var()</mark>——求样本方差</p></li><li class="lvl-2"><p><mark>std()</mark>——求样本标准差</p></li></ul><hr><ul class="lvl-0"><li class="lvl-2"><p><mark>Jarque-Bera检验</mark>，该检验基于数据样本的偏度和峰度，评价给定数据是否服从未知均值和方差的正态分布的假设。对于正态分布数据，样本偏度接近于0，样本峰度接近于3。</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>>h  = jbtest(X)——对输入数据矢量X进行Jarque-Bera检验，返回检验结果h。若h=1，则在显著性水平0.05下拒绝X服从正态分布的假设；若h = 0，则可认为X服从正态分布h = jbtest(X,alpha)——在显著性水平alpha下进行Jarque-Bera检验。[H,P,JBSTAT,CV] = jbtest(X,alpha)——返回其他三个输出。P为检验的p值，JBSTAT为检验统计量，CV为确定是否拒绝零假设的临界值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="2-3-2-随机数">2.3.2 随机数</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>binornd()</mark>——二项分布随机数</p></li><li class="lvl-2"><p><mark>poisspdf()</mark>——泊松分布随机数</p></li><li class="lvl-2"><p><mark>unifrnd()</mark>——均匀分布随机数</p></li><li class="lvl-2"><p><mark>normrnd()</mark>——正态分布随机数</p></li></ul><p>······</p><h4 id="2-3-3-假设检验">2.3.3 假设检验</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>ztest()</mark>——方差已知时的均值假设检验</p></li><li class="lvl-2"><p><mark>ttest()</mark>——方差未知时单个正态总体均值的假设检验</p></li><li class="lvl-2"><p><mark>ttest2()</mark>——方差未知时两个正态总体均值的假设检验</p></li></ul><h4 id="2-3-4-方差分析">2.3.4 方差分析</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>anoval()</mark></p></li></ul><h4 id="2-4-统计图表的绘制">2.4 统计图表的绘制</h4><p>1.正整数的频率表</p><ul class="lvl-0"><li class="lvl-2"><p><mark>tabulate(X)</mark></p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> A = [1 1 4 5 1 4]tabulate(A)A =     1     1     4     5     1     4  Value    Count   Percent      1        3     50.00%      2        0      0.00%      3        0      0.00%      4        2     33.33%      5        1     16.67%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.经验累积分布函数图像</p><ul class="lvl-0"><li class="lvl-2"><p><mark>[h,stats] = cdfplot()</mark>——h表示曲线的环柄，stats表示一些样本特征</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> X = normrnd(0,1,50,1);[h,stats] = cdfplot(X)h =   Line - 属性:              Color: [0 0.4470 0.7410]          LineStyle: '-'          LineWidth: 0.5000             Marker: 'none'         MarkerSize: 6    MarkerFaceColor: 'none'              XData: [-Inf -2.1495 -2.1495 -1.6747 -1.6747 -1.6105 -1.6105 -1.5305 -1.5305 -1.4487 -1.4487 … ]              YData: [0 0 0.0200 0.0200 0.0400 0.0400 0.0600 0.0600 0.0800 0.0800 0.1000 0.1000 0.1200 0.1200 … ]  显示 所有属性stats =   包含以下字段的 struct:       min: -2.1495       max: 2.6825      mean: -0.1385    median: -0.1591       std: 1.0113<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F18.png" alt=""></p><p>3.最小二乘拟合直线</p><ul class="lvl-0"><li class="lvl-2"><p><mark>lsline</mark></p></li></ul><p>4.绘制正态分布概率图形</p><ul class="lvl-0"><li class="lvl-2"><p><mark>normplot(X)</mark>——若X为向量，则显示正态分布概率图形；若X为矩阵，则显示每一列的正态分布概率图形</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> A = [0 5 1 1 2 3 0 3 0 1 1 8];normplot(A)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F19.png" alt=""></p><p>5.绘制威布尔概率图形</p><ul class="lvl-0"><li class="lvl-2"><p><mark>wblplot(X)</mark>——若X为向量，则显示威布尔概率图形；若X为矩阵，则显示每一列的威布尔概率图形</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> A = [0 5 1 1 2 3 0 3 0 1 1 8];weibplot(A)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>6.样本数据的盒图</p><ul class="lvl-0"><li class="lvl-2"><p><mark>boxplot</mark></p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> X1 = normrnd(5,1,100,1);X2 = normrnd(6,1,100,1);x = [X1 X2];boxplot(x,1,'|',1,0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>7.增加参考线</p><ul class="lvl-0"><li class="lvl-2"><p><mark>refline(slope,intercept)</mark>——slope表示斜率，intercept表示截距</p></li><li class="lvl-2"><p><mark>refline(slope,intercept)</mark>——slope = [a b]，图中加一条直线y=ax+b</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> XJY = [0 5 1 1 2 3 0 3 0 1 1 8]';plot(XJY)refline(0.1,-1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F20.png" alt=""></p><p>8.增加多项式曲线</p><ul class="lvl-0"><li class="lvl-2"><p><mark>refcurve()</mark>——在当前图形中加入一条多项式曲线</p><p>h = refcurve(p)——在图中加入一条多项式曲线，h为曲线的环柄，p为多项式系数向量，p = [p1,p2,p3,···,pn]，其中p1为最高幂项系数。</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> h = [95 172 220 269 349 281 423 437 432 478 556 430 410 356];plot(h,'r')refcurve([-6,120,-10])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F21.png" alt=""></p><p>9.样本概率图形</p><ul class="lvl-0"><li class="lvl-2"><p><mark>p = capaplot(data,specs)</mark>——返回来自于估计分布的随机变量落在指定范围内的概率。data为所给样本数据，specs为指定范围，p表示在指定范围内的概率</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> h = [95,172,220,269,349,281,423,437,432,478,556,430,410,356];p = capaplot(h,[100,300])p =    0.3213<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F22.png" alt=""></p><p>10.附加有正态密度曲线的直方图</p><ul class="lvl-0"><li class="lvl-2"><p><mark>histfit(data)</mark>——data为向量，返回直方图和正态曲线</p></li><li class="lvl-2"><p><mark>histfit(data,nbins)</mark>——nbins指定bat的个数</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> A = normrnd(5,10,1,20);histfit(A)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F23.png" alt=""></p><p>11.在指定的界限之间画正态密度曲线</p><ul class="lvl-0"><li class="lvl-2"><p><mark>p = normspec(specs,mu,sigma)</mark>——specs指定界限，mu、sigma为正态分布的参数，p为样本落在上、下界之间的概率。</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>>  normspec([50,inf],200,100)ans =    0.9332<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F24.png" alt=""></p><h4 id="2-5-回归模型">2.5 回归模型</h4><p>回归分析是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。</p><p>回归分析通常分为一元线性回归分析、多元线性回归分析、非线性回归分析、曲线估计、时间序列的曲线估计、含虚拟变量的回归分析和逻辑回归分析等类型</p><p>1.一元线性回归</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> x = 1:10;y = [2650 1942 1493 1086 766 539 485 291 224 202];for i = 1:10 plot(x(i),y(i),'ok'); hold onendxlabel('x');ylabel('y');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F25.png" alt=""></p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> x = 1:10;y = [2650 1942 1493 1086 766 539 485 291 224 202];z = zeros(size(y));N = length(y);for i = 1:N z(i) = log(y(i)); plot(x(i),z(i),'ok'); hold onendxlabel('x');ylabel('z');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F26.png" alt=""></p><p>2.多元线性回归</p><ul class="lvl-0"><li class="lvl-2"><p><mark>[b,bint,r,rint,stats] = regress(y,x,alpha)</mark>——y为因变量数据向量，x为自变量数据向量，alpha为显著性水平（缺省时设定为0.05）。b为输出向量，bint为回归系数估计值和它们的置信区间，r为残差，rint为置信区间，stats是用于检验回归模型的统计量。</p></li><li class="lvl-2"><p><mark>注意y，x的输入格式！</mark></p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> x1 = [1.376 1.375 1.378 1.401 1.412 1.428 1.445 1.477];x2 = [0.450 0.475 0.485 0.500 0.535 0.545 0.550 0.575];x3 = [2.170 2.554 2.676 2.713 2.823 3.088 3.122 3.262];x4 = [0.8922 1.1610 0.5346 0.9589 1.0239 1.0499 1.1065 1.1387];y = [5.19 5.30 5.60 5.82 6.00 6.06 6.45 6.95];save data x1 x2 x3 x4 yload data     %%取出数据Y = y';X = [ones(size(x1')),x1',x2',x3',x4'];[b,bint,r,rint,stats] = regress(Y,X)b =  -13.3547   12.8531    1.7866    0.2071   -0.3714bint =  -25.5633   -1.1461    0.6278   25.0784  -16.2410   19.8142   -1.4491    1.8632   -1.2072    0.4644r =   -0.0631    0.0354    0.0211    0.0686    0.0460   -0.1627    0.0138    0.0409rint =   -0.1322    0.0060   -0.2061    0.2769   -0.1355    0.1777   -0.4556    0.5927   -0.0073    0.0993   -0.3143   -0.0111   -0.5014    0.5291   -0.2791    0.3608stats =    0.9830   43.2851    0.0055    0.0136<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即Y于X的模型为：</p><p>Y = -13.3547 + 12.8531 * x1 + 1.7866 * x2 + 0.2071 * x3 - 0.3714 * x4</p><h3 id="第三章-MATLAB程序设计">第三章 MATLAB程序设计</h3><h4 id="3-1-自顶向下的程序设计方法">3.1 自顶向下的程序设计方法</h4><p>以列主元高斯消元法为例</p><h4 id="3-2-符号运算">3.2 符号运算</h4><h4 id="3-2-1-符号对象">3.2.1 符号对象</h4><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> a1 = [1/3, pi/7, sqrt(5), pi+sqrt(5)]a2 = sym([1/3, pi/7, sqrt(5), pi+sqrt(5)])a3 = sym([1/3, pi/7, sqrt(5), pi+sqrt(5)],'e')a4 = str2sym('[1/3, pi/7, sqrt(5), pi+sqrt(5)]')a1 =    0.3333    0.4488    2.2361    5.3777a2 =[1/3, pi/7, 5^(1/2), 189209612611719/35184372088832]a3 =[1/3 - eps/12, pi/7 - (13*eps)/165, (137*eps)/280 + 5^(1/2), 189209612611719/35184372088832]a4 =[1/3, pi/7, 5^(1/2), pi + 5^(1/2)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> a5 = sym(str2sym('[1/3, pi/7, sqrt(5), pi+sqrt(5)]'))a5 =[1/3, pi/7, 5^(1/2), pi + 5^(1/2)]%%可以看到a5的表达形式同a4非常像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-2-创建符号对象">3.2.2 创建符号对象</h4><p>1.函数命令sym()的调用格式</p><ul class="lvl-0"><li class="lvl-2"><p><mark>S = sym(A)</mark>——由A来建立一个符号对象S，其类型为sym类型。A为数字（值）或数值矩阵或数值表达式，则输出是将数值对象转换成符号对象。</p></li><li class="lvl-2"><p><mark>S = sym(‘A’)</mark>——A为不带 ‘[’ 、 ‘]’ 的字符串，将此字符串转换为符号对象。</p></li><li class="lvl-2"><p><mark>S = sym(str2sym(‘[   ]’)或S = str2sym(’[   ]')</mark></p></li><li class="lvl-2"><p><mark>S = sym(A,flag)</mark>——命令功能同S = sym(A)。flag可以去以下选项</p><ul class="lvl-2"><li class="lvl-4"><p>’r‘——默认设置，最接近有理表示的形式。这种形式是指用两个正整数p、q构成的p/q、p*pi/q、sqrt(q)、2<sup>p、q</sup>10表示的形式之一</p></li><li class="lvl-4"><p>‘d’——最接近的十进制浮点精确表示；</p></li><li class="lvl-4"><p>’e‘——带估计误差的有理表示</p></li><li class="lvl-4"><p>’f‘——十六进制浮点表示</p></li></ul></li><li class="lvl-2"><p><mark>S = sym(‘A’,flag)</mark>——命令功能同S = sym(’A‘)。只不过转换成的符号对象应按flag指定的要求。flag可取以下“限定性”选项：</p><ul class="lvl-2"><li class="lvl-4"><p>‘positive’——限定A为正的实型符号变量</p></li><li class="lvl-4"><p>’real‘——限定A为实型符号变量</p></li><li class="lvl-4"><p>’unreal‘——限定A为非实型符号变量</p></li></ul></li></ul><p>2.函数命令syms()的调用格式</p><ul class="lvl-0"><li class="lvl-2"><p><mark>syms s1 s2 s3 flag</mark>——flag限定性同上</p></li></ul><p>3.函数命令class( )的调用格式</p><ul class="lvl-0"><li class="lvl-2"><p>str = class(object)——返回指代数据对象类型的字符串。</p></li></ul><h4 id="3-2-3-符号表达式及函数">3.2.3 符号表达式及函数</h4><p>在不指明自变量的情况下，按照数学常规，自变量通常都是小写英文字母，并且为字母表末尾的几个，如t、w、x、y、z等。</p><ul class="lvl-0"><li class="lvl-2"><p><mark>findsym(f,n)</mark>——按照数学习惯确定<u>符号函数f</u>中的n个自变量。当指定n=1时，从符号函数f中找出在字母表中与x最近的字母；如果有两个字母与x的距离相等，则取较后一个。当输入参数n缺省时，函数命令将给出f中所有的符号变量。</p></li><li class="lvl-2"><p><mark>findsym(e,n)</mark>——这种格式的功能是按数学习惯确定<u>符号方程e</u>中的n个自变量</p></li></ul><h4 id="3-3-关系运算符和逻辑运算符">3.3 关系运算符和逻辑运算符</h4><h4 id="3-3-1-关系运算符">3.3.1 关系运算符</h4><p>== 等于</p><p>~= 不等于</p><h4 id="3-3-2-逻辑运算符">3.3.2 逻辑运算符</h4><p>1.逐个元素的逻辑运算</p><p>逻辑与&amp;、逻辑或|、逻辑非~</p><p>2.捷径逻辑运算</p><p>逻辑与&amp;&amp;、逻辑或||</p><p>3.逐位逻辑运算</p><ul class="lvl-0"><li class="lvl-2"><p><mark>bitand(a,b)</mark>——逐位逻辑与</p></li><li class="lvl-2"><p><mark>bitor(a,b)</mark>——逐位逻辑或</p></li><li class="lvl-2"><p><mark>bitcmp(a,b)</mark>——逐位逻辑非</p></li><li class="lvl-2"><p><mark>bitxor(a,b)</mark>——逐位逻辑异或</p></li></ul><h4 id="3-3-3-常用操作函数">3.3.3 常用操作函数</h4><ul class="lvl-0"><li class="lvl-2"><p>xor(x,y)——异或运算</p></li><li class="lvl-2"><p>any(x)——如果在一个向量x中，任何元素是非零，返回1；矩阵x中的每一列有非零元素，返回1</p></li><li class="lvl-2"><p>all(x)——如果在一个向量x中，所有元素非零，返回1；矩阵x中的每一列所有元素非零，返回1</p></li></ul><h4 id="3-4-分支结构">3.4 分支结构</h4><h4 id="3-4-1-if分支结构">3.4.1 if分支结构</h4><p>if <code>expression</code><br><code>statements</code><br>elseif <code>expression</code><br><code>statements</code><br>else<br><code>statements</code><br>end</p><h4 id="3-4-2-switch分支结构">3.4.2 switch分支结构</h4><p>switch <code>switch_expression</code></p><pre><code>case `case_expression`  `statements` ...otherwise   `statements` </code></pre><p>end</p><h4 id="3-5-循环结构2">3.5 循环结构2.</h4><h4 id="3-5-1-while循环结构">3.5.1 while循环结构</h4><p>while <code>expression</code><br><code>statements</code><br>end</p><h4 id="3-5-2-for循环结构">3.5.2 for循环结构</h4><p>for <code>index</code> = <code>values</code><br><code>statements</code><br>end</p><h4 id="3-5-3-控制程序的其他命令">3.5.3 控制程序的其他命令</h4><p>1.continue</p><p>2.break</p><p>3.return</p><p>4.input</p><ul class="lvl-0"><li class="lvl-2"><p><mark>input()</mark></p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> a = input('input a number:','s')b = input('input a number:')input a number:66na =    '66n'input a number:6b =     6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.keyboard——使程序暂停运行，等待键盘命令<br>6.error和warning</p><ul class="lvl-0"><li class="lvl-2"><p><mark>error(‘message’)</mark>——显示出错信息message，终止程序</p></li><li class="lvl-2"><p><mark>errordlg(‘errorstring’,‘dlgname’)</mark>——显示出错信息的对话框，对话框的标题为dlgname</p></li><li class="lvl-2"><p><mark>warning(‘message’)</mark>——显示出错信息message，程序继续进行</p></li></ul><h4 id="3-6-程序调试和优化">3.6 程序调试和优化</h4><h4 id="3-6-1-程序调试命令">3.6.1 程序调试命令</h4><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">- dbstop     - Set breakpoint                      %设置断点- dbclear    - Remove breakpoint                   %清除断点- dbcont     - Resume execution                    %重新执行- dbdown    - Change local workspace context       %下移本地工作空间内容- dbmex     - Enable MEX-file debugging            %使MEX文件调试有效- dbstack    - List who called whom                %列出函数调用关系- dbstatus    - List all breakpoints               %列出所有断点- dbstep     - Execute one or more lines           %单步或多步执行- dbtype     - List M-file with line numbers       %列出M文件- dbup      - Change local workspace context       %上移本地工作空间内容- dbquit     - Quit debug mode                     %退出调试模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F26-27.png" alt=""></p><h4 id="3-6-2-经典算法程序举例">3.6.2 经典算法程序举例</h4><ol><li class="lvl-3"><p>雅可比（Jacobi）迭代算法——解方程组常用算法</p></li><li class="lvl-3"><p>拉格朗日插值函数算法——求解插值点处的函数值</p></li><li class="lvl-3"><p>图论相关算法</p><ol><li class="lvl-6"><p>最小生成树</p></li><li class="lvl-6"><p>最短路径Dijkstra算法</p></li><li class="lvl-6"><p>Ford算法</p></li><li class="lvl-6"><p>模糊聚类分析算法程序（组）</p></li><li class="lvl-6"><p>层次分析——求近似特征向量算法</p></li><li class="lvl-6"><p>灰色关联分析——单因子情形</p></li><li class="lvl-6"><p>灰色预测——GM（1，1）</p></li></ol></li></ol><h3 id="第四章-常用建模函数">第四章 常用建模函数</h3><h4 id="4-1-曲线拟合函数">4.1 曲线拟合函数</h4><h4 id="4-1-1-多项式拟合">4.1.1 多项式拟合</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>polyfit(x,y,n)</mark>——找到次数为n的多项式系数，对于数据集合{(xi,yi)}，满足差的平方和最小</p></li><li class="lvl-2"><p><mark>[p,E]=polyfit(x,y,n)</mark>——返回同上的多项式p和矩阵E。多项式系数在向量p中，矩阵E用在polyval函数中计算误差。</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> x = [0.3 0.4 0.7 0.9 1.2 1.9 2.8 3.2 3.7 4.5];y = [1 2 3 4 5 2 6 9 2 7];p5 = polyfit(x,y,5);    %5阶多项式拟合y5 = polyval(p5,x);     %计算多项式 p 在 x 的每个点处的值p5                      %显示p5向量p5 = vpa(poly2sym(p5),5)%显示5阶多项式p9 = polyfit(x,y,9);    %9阶多项式拟合y9 = polyval(p9,x);figure;                 %画图显示plot(x,y,'bo');hold on;plot(x,y5,'r:');plot(x,y9,'g--');legend('原始数据','5阶多项式拟合','9阶多项式拟合');xlabel('x');ylabel('y');p5 =    0.8877  -10.3002   42.9421  -77.9316   59.8332  -11.6732p5 =0.8877*x^5 - 10.3*x^4 + 42.942*x^3 - 77.932*x^2 + 59.833*x - 11.673<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F27.png" alt=""></p><h4 id="4-1-2-加权最小方差拟合">4.1.2 加权最小方差拟合</h4><h4 id="4-1-3-非线性曲线拟合">4.1.3 非线性曲线拟合</h4><p>非线性曲线拟合是已知输入向量xdata、输出向量ydata，并直到输入与输出的函数关系为ydata = F(x,xdata)，但不清楚系数向量x。进行曲线拟合即求x使得下式成立：</p><p>$$<br>minx(1/2)||F(x,xdata)−ydata||<sup>2_2=12∑(F(x,xdatai)−ydatai)</sup>2<br>$$</p><ul class="lvl-0"><li class="lvl-2"><p>x = <mark>lsqcurvefit(fun, x0, xdata, ydata)</mark>——x0为初始解向量；xdata、ydata为满足关系ydata = F(x,xdata)的数据。</p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox0"><label for="checkbox0">。</label></p></li><li class="lvl-2"><p>x = lsqcurvefit(fun, x0, xdata, ydata, lb, ub, options)——options为指定的优化参数</p></li><li class="lvl-2"><p>[x ,resnorm, residual, exitflag, output] = lsqcurvefit(···)——resnorm是在x处残差和的平方和，residual为在x处的残差，exitflag为终止迭代的条件，output为输出的优化信息。</p></li></ul><h4 id="4-2-参数估计函数">4.2 参数估计函数</h4><h4 id="4-2-1-常见分布的参数估计">4.2.1 常见分布的参数估计</h4><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F27-28.png" alt=""></p><h4 id="4-2-2-点估计">4.2.2 点估计</h4><p>点估计是用单个数值作为参数的估计，目前使用较多的方法是最大似然法和矩法</p><p>1.最大似然法</p><p><mark>pha = mle(‘dist’,data)</mark>——使用data适量中的样本数据，返回<u>dist指定的分布</u>的最大似然估计</p><p>2.矩法</p><p><mark>moment(X,order)</mark></p><h4 id="4-2-3-区间估计">4.2.3 区间估计</h4><p>求参数的区间估计，首先要求出该参数的点估计，然后构造一个含有该参数的随机变量，并根据一定的置信水平求该估计值的范围。</p><p><mark>mle()</mark></p><h4 id="4-3-参数传递函数">4.3 参数传递函数</h4><h4 id="4-3-1-输入和输出参数的数目">4.3.1 输入和输出参数的数目</h4><p>MATLAB中可以通过<mark>nargin</mark>和<mark>nargout</mark>函数，确定函数调用时实际传递的输入和输出参数个数，结合条件分支语句，就可以处理函数调用中指定不同数目的输入/输出参数的情况。</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">function [n1,n2] = mythe(m1,m2)if nargin == 1    n1 = m1;    if nargout == 2        n2 = m1;    endelse    if nargout == 1        n1 = m1 + m2;    else        n1 = m1;        n2 = m2;    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> m = mythe(4)m =     4>> [m,n] = mythe(4)m =     4n =     4>> m = mythe(4,8)m =    12>> [m,n] = mythe(4,8)m =     4n =     8>> mythe(4,8)ans =     4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-2-可变数目的参数传递">4.3.2 可变数目的参数传递</h4><p>某些情况下，用户可能并不确定具体调用中传递的输入参数或输出参数的个数，即具有可变数目的传递参数。MATLAB中可通过<mark>varargin</mark>和<mark>varargout</mark>函数实现可变数目的参数传递，使用这两个函数对于处理具有复杂的输入/输出参数个数组合的情况也是便利的。</p><blockquote><p><code>varargin</code>&nbsp;是函数定义语句中的一个输入变量，允许函数接受任意数量的输入参数。使用小写字符指定&nbsp;<code>varargin</code>，将其作为最后一个输入参数附加在任何显式声明的输入项后。</p><p>在执行函数时，<code>varargin</code>&nbsp;是一个 1×N 元胞数组，其中 N 是函数在显式声明的输入后收到的输入项数。但是，如果该函数在显式声明的输入后未收到任何输入，则&nbsp;<code>varargin</code>&nbsp;是空元胞数组。</p></blockquote><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F28.png" alt=""></p><h4 id="4-3-3-返回被修改的输入参数">4.3.3 返回被修改的输入参数</h4><p>同C语言，在函数内修改的工作区变量x不会改变实参x，除非返回到x</p><h4 id="4-3-4-全局变量">4.3.4 全局变量</h4><p>关键词<mark>global</mark></p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">function y = azhe(x)    global A;    A = A + 9;    y = cos(x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> global A;azhe(1)ans =    0.5403>> AA =    11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-插值函数">4.4 插值函数</h4><p>插值是指在所给的基准数据情况下，研究如何平滑地估算出基准数据之间其他点的函数数值。每当其他点上函数值获取的代价比较高时，插值就会发挥作用。</p><h4 id="4-4-1-一维插值命令及实例">4.4.1 一维插值命令及实例</h4><p>MATLAB中，一维插值有基于多项式的插值和基于快速傅里叶的插值的两种类型。一维插值就是对一维函数y = f(x)进行插值。</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F28-29.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F29.png" alt=""></p><h4 id="4-4-2-二维插值命令及实例">4.4.2 二维插值命令及实例</h4><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F29-30.png" alt=""></p><p>meshgrid函数用来生成二维和三维网格</p><blockquote><p><mark>[X,Y] = meshgrid(x,y) </mark>基于向量 x 和 y 中包含的坐标返回二维网格坐标。X 是一个矩阵，每一行是 x 的一个副本；Y 也是一个矩阵，每一列是 y 的一个副本。坐标 X 和 Y 表示的网格有 length(y) 个行和 length(x) 个列。</p><p><mark>[X,Y] = meshgrid(x)</mark> 与 [X,Y] = meshgrid(x,x) 相同，并返回网格大小为 length(x)×length(x) 的方形网格坐标。</p><p><mark>[X,Y,Z] = meshgrid(x,y,z) </mark>返回由向量 x、y 和 z 定义的三维网格坐标。X、Y 和 Z 表示的网格的大小为 length(y)×length(x)×length(z)。</p><p><mark>[X,Y,Z] = meshgrid(x) </mark>与 [X,Y,Z] = meshgrid(x,x,x) 相同，并返回网格大小为 length(x)×length(x)×length(x) 的三维网格坐标。</p></blockquote><h4 id="4-4-3-样条插值">4.4.3 样条插值</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>yy = spline(x,y,xx)</mark>——对于给定的离散的测量数据x、y(称为断点)，要寻找一个三项多项式y = p(x)，以逼近每对数据(x,y)点间的曲线。</p></li><li class="lvl-2"><p><mark>pp = spline(x,y)</mark>——返回由向量x与y确定的分段样条多项式的系数矩阵pp，它可用于命令<mark>ppval</mark>、<mark>unmkpp</mark>的计算。</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> x = [0 2 4 5 8 12 12.8 17.2 19.9 20];y = exp(x).*sin(x);xx = 0:0.25:20;yy = spline(x,y,xx);plot(x,y,'h',xx,yy,':black')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F30.png" alt=""></p><h3 id="第九章-MATLAB数据图形可视化">第九章 MATLAB数据图形可视化</h3><h4 id="9-1-MATLAB图形窗口">9.1 MATLAB图形窗口</h4><h4 id="9-1-1-创建图形窗口">9.1.1 创建图形窗口</h4><p>使用<mark>figure</mark>来建立图形窗口。</p><p><mark>figure(x)</mark>——x为正整数，就会得到图形框名称为x的图形，直接输入figure默认显示图形框名称为1.</p><h4 id="9-1-2-关闭与清楚图形框">9.1.2 关闭与清楚图形框</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>close</mark>——关闭当前图形窗口，等效于close(gcf)</p></li><li class="lvl-2"><p><mark>close(x)</mark>——关闭图形句柄指定的图形窗口</p></li><li class="lvl-2"><p><mark>close name</mark>——关闭图形窗口名name指定的图形窗口</p></li><li class="lvl-2"><p><mark>close all</mark>——关闭除隐含图形句柄的所有图形窗口</p></li><li class="lvl-2"><p><mark>close all hidden</mark>——关闭包括隐含图形句柄的所有图形窗口</p></li><li class="lvl-2"><p><mark>status = close(···)</mark>——调用close函数正常关闭图形窗口时，返回1，否则返回0。</p></li><li class="lvl-2"><p><mark>clf</mark>——清楚当前图形窗口所有可见的图形对象</p></li><li class="lvl-2"><p><mark>clf reset</mark>——清楚当前图形窗口所有可见的图形对象，并将窗口的属性设置为默认值</p></li></ul><h4 id="9-2-函数绘制">9.2 函数绘制</h4><h4 id="9-2-1-一元函数绘图">9.2.1 一元函数绘图</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>ezplot(f)</mark>——按照x的默认取值范围（-2<em>pi&lt;x&lt;2</em>pi）绘制f = f(x)的图形。对于f = f(x,y)，则绘制f(x,y) = 0的图形</p></li><li class="lvl-2"><p><mark>ezplot(f,[min,max])</mark>——按照x的指定范围（min&lt;x&lt;max）绘制f = f(x)的图形。</p></li><li class="lvl-2"><p><mark>ezplot(x,y)</mark>——按照t的默认范围(-2<em>pi&lt;t&lt;2</em>pi)绘制x=x(t)、y=y(t)的图形。</p></li><li class="lvl-2"><p><mark>ezplot(f,[xmin,xmax,ymin,ymax])</mark>——按照指定的x,y取值范围，在图形窗口绘制函数f = f(x,y)的图形。</p></li><li class="lvl-2"><p><mark>ezplot(x,y,[tmin,tmax])</mark>——按照t的指定范围绘制x = x(t)、y = y(t)的图形。</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> syms x yf = x.^3 + y.^2 - 3;ezplot(f)>> f = 'x.^3 + y.^2 - 3';ezplot(f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F31.png" alt=""></p><h4 id="9-2-2-二元函数绘图">9.2.2 二元函数绘图</h4><p>1.函数<mark>ezmesh</mark></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F31-32.png" alt=""></p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> syms s tx = 's^(2*t)；y = 'cos(s)^2+t'；z = 'sin(s)*tan(t)'；figureezmesh(x,y,z)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F32.png" alt=""></p><p>2.<mark>meshgrid</mark>、<mark>surf()</mark>——创建三维曲面图</p><p>对于二元函数z = f(x,y)，每一对x和y的值产生一个z的值，作为x与y的函数，z是三维空间的一个曲面。MATLAB将z存放在一个矩阵中，z的行和列分别表示为：</p><p>$$<br>z(i,:) = f(x,y(i)<br>$$</p><p>$$<br>z(:,i) = f(x(i,y)<br>$$</p><p>当z = f(x,y)能用简单的表达式表示时，利用meshgrid函数可以方便地获得所有z地数据，然后用前面讲过的画三维图形的命令就可以绘制二元函数z = f(x,y)。</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">x = 0:0.5:4;y = -5:0.2:3;[X,Y] = meshgrid(x,y);Z = cos(X).*cos(Y);surf(X,Y,Z);    %创建三维曲面图xlabel('X'),ylabel('Y'),zlabel('Z');title('Z = cos(X).*cos(Y)');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F33.png" alt=""></p><h4 id="9-3-数据图形绘制简介">9.3 数据图形绘制简介</h4><h4 id="9-3-1-离散数据可视化">9.3.1 离散数据可视化</h4><p>1.<mark>stem</mark></p><ul class="lvl-0"><li class="lvl-2"><p><mark>stem(y)</mark>——以x=1,2,3···作为各个数据点的x坐标，以向量y的值为y坐标，在(x,y)坐标点画一个空心小圆圈，并连接一条线段到X轴</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> figuret = linspace(-2*pi,2*pi,8)h = stem(t)set(h,'Color','blue')t =   -6.2832   -4.4880   -2.6928   -0.8976    0.8976    2.6928    4.4880    6.2832h =   Stem - 属性:              Color: [0 0.4470 0.7410]          LineStyle: '-'          LineWidth: 0.5000             Marker: 'o'         MarkerSize: 6    MarkerFaceColor: 'none'          BaseValue: 0              XData: [1 2 3 4 5 6 7 8]              YData: [-6.2832 -4.4880 -2.6928 -0.8976 0.8976 2.6928 4.4880 6.2832]  显示 所有属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F34.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p><mark>stem(x,y,‘option’)</mark>——以x向量的各个元素为x坐标，以y向量的各个元素为y坐标，在(x,y)坐标点画一个空心小圆圈，并连接一条线段到X轴。option选项表示绘图时的线型、颜色等设置。</p></li><li class="lvl-2"><p><mark>stem(x,y,‘filled’)</mark>——filled表示点为实心</p></li></ul><p>2.<mark>plot</mark></p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> a = linspace(-100,100,21);b = (a.^2+sqrt(a))/1000;plot(a,b,'rh','MarkerSize',15)grid on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F35.png" alt=""></p><h4 id="9-3-2-连续函数可视化">9.3.2 连续函数可视化</h4><p><mark>plot</mark>（若不用关键字或者显示某个具体点的内容，plot函数默认用直线连接各个离散点）</p><p>关键字：</p><ol><li class="lvl-3"><p><code>Color</code>——线条颜色</p></li><li class="lvl-3"><p><code>LineStyle</code>——线型</p></li><li class="lvl-3"><p><code>LineWidth</code>——线条宽度</p></li><li class="lvl-3"><p><code>Marker</code>——标记符号</p></li><li class="lvl-3"><p><code>MarkerIndices</code>——要显示标记的数据点的索引（每隔多少个标记一个、标记特定的点）</p></li><li class="lvl-3"><p><code>MarkerEdgeColor</code>——标记轮廓颜色</p></li><li class="lvl-3"><p><code>MarkerFaceColor</code>——标记填充颜色</p></li><li class="lvl-3"><p><code>MarkerSize</code>——标记大小</p></li><li class="lvl-3"><p><code>DatetimeTickFormat - datetime</code>——刻度标签的格式</p></li><li class="lvl-4"><p><code>DurationTickFormat - duration</code>——刻度标签的格式</p></li></ol><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">plot(x,y,'-o','MarkerIndices',[1 5 10])              % 在第1、第5和第10个数据点处显示圆形标记。plot(x,y,'-x','MarkerIndices',1:3:length(y))         % 每隔2个数据点显示1个交叉标记。plot(x,y,'Marker','square','MarkerIndices',5)           % 在第5个数据点显示1个正方形标记。plot(x,y,'-or','MarkerIndices',1:8:length(y),'LineWidth',3,'MarkerSize',10,'MarkerEdgeColor','b','MarkerFaceColor','g')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-4-二维绘图函数">9.4 二维绘图函数</h4><h4 id="9-4-1-二维图形绘制步骤">9.4.1 二维图形绘制步骤</h4><p>1.数据准备</p><p>2.指定图形窗口和位置</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">figure(1)        指定一号窗口subplot(2,2,3)   将当前图窗划分为2×2网格，并在坐标区3创建图形<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>3.绘制图形</p><p>设置曲线的绘制方式，包括线型、色彩、数据点形等</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">plot(t,y,'b-')   用蓝实线画曲线<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.设置坐标轴和图形注释</p><p>设置坐标轴包括坐标的范围、刻度和坐标分割线等，图形注释包括图名、坐标名、图例、文字说明等。</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">title('调制波形')            图名xlabel('t')ylabel('y')                 轴名legend('sin(t)')            图例text(2,0.5,'y = sin(t)')    文字axis([0,pi,-1,1])           设置轴的范围grid on                     画坐标分割线<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.图形的精细修饰</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">e.g.set(h,'MakerSize',10)        设置数据点大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>6.按指定格式保存或导出图形</p><p>将绘制的图形窗口保存为<code>.fig</code>文件，或者转换成其他图形文件、</p><h4 id="9-4-2-快速方程式画图">9.4.2 快速方程式画图</h4><p>1.fplot</p><p>单纯画方程式图形，图形之上(x,y)坐标值会自动取，但必须输入x坐标的范围。</p><ul class="lvl-0"><li class="lvl-2"><p><mark>fplot(‘方程式’,[xmin,xmax,ymin,ymax])</mark></p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> fplot('x-cos(x^2)-sin(2*x^3)',[-4,4])警告: 在以后的版本中，fplot 将不接受字符向量或字符串输入。请改用 fplot(@(x)x-cos(x.^2)-sin(2.*x.^3))。 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F36.png" alt=""></p><p>2.ezplot</p><ul class="lvl-0"><li class="lvl-2"><p><mark>ezplot</mark>——见9.2.1</p></li></ul><h4 id="9-4-3-特殊二维图形">9.4.3 特殊二维图形</h4><h5 id="1-特殊坐标图形的绘制">1.特殊坐标图形的绘制</h5><p><em><strong>1)极坐标系</strong></em></p><ul class="lvl-0"><li class="lvl-2"><p><mark>polar(theta,rho,LineSpec)</mark>——theta是用弧度制表示的角度，rho是对应的半径。极角theta为从x轴到半径的单位为弧度的向量，极径rho为各数据点到极点的半径向量，LineSpec指定极坐标图中线条的线型、标记符号和颜色等。</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> t = 0:0.1:3*pi;    %极坐标角度a = -2*pi:.001:2*pi;  %设定极坐标角度b = (1-sin(a));       %设定对应角度的半径figure(1)title('极坐标图形')subplot(1,2,1);       %在区域1绘图polar(t,abs(cos(5*t)))%绘制图一hold on;subplot(1,2,2);       %在区域2绘图polar(a,b,'r');       %绘制图二<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F37.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F38.png" alt=""></p><p><em><strong>2)对数坐标系</strong></em></p><ul class="lvl-0"><li class="lvl-2"><p><mark>semilogx(x,y)</mark>——x轴对数刻度坐标图，即用该函数绘制图形时x轴采用对数坐标。</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> x = 0:1000;y = log(x);semilogx(x,y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F39.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p><mark>semilogx(y)</mark>——对x轴的刻度求常用对数（以10为底），而y为线性刻度。</p></li></ul><p>若y为实数向量或矩阵，则semilogx(y)结合y列向量的下标与y的列向量画出线条，即<u>以y列向量的索引值为横坐标，以y列向量的值为纵坐标</u></p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> y = [21 35 26 8465 28 39 6862 71 59 34];semilogx(y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F40.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p><mark>semilogy(x,y)</mark>——y轴对数刻度坐标图，用该函数绘制图形时y轴采用对数坐标。</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> x = 0.001 : 0.1*pi : 2*pi;y = 10.^x;figuresubplot(2,1,1)semilogy(x,y,'r-')hold onsubplot(2,1,2)plot(x,y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F41.png" alt="">*</p><p><em><strong>3)柱坐标系</strong></em></p><p>在MATLAB中没有在柱坐标和球坐标下直接绘制数据图形的命令，但pol2cart命令能够将柱坐标和球坐标值转化为直角坐标系下的坐标值，然后在直角坐标下绘制数据图形。</p><blockquote><p>1：柱坐标系(r,φ,z)与<a href="https://baike.baidu.com/item/%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB/1835293?fromModule=lemma_inlink">直角坐标系</a>(x,y,z)的转换关系：</p><p>$$<br>x=rcosφ<br>\<br>y=rsinφ<br>\<br>z=z<br>$$<br>2：同样的，直角坐标系（x，y，z）与柱坐标系(r,φ,z)的转换关系：</p><p>$r = \sqrt{x<sup>2+y</sup>2}$</p><p>$\varphi = arctan(\dfrac{y}{x})$</p><p>$z=z$</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><mark>[x,y] = pol2cart(theta,rho,)</mark></p></li><li class="lvl-2"><p><mark>[x,y,z] = pol2cart(theta,rho,z)</mark></p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> theta = 0 : pi/20 : 2*pi;rho = sin(theta);[t,r] = meshgrid(theta,rho);z = r.*t;[X,Y,Z,] = pol2cart(t,r,z);mesh(X,Y,Z)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F42.png" alt=""></p><p><em><strong>4)球坐标系</strong></em></p><p>在MATLAB中可以使用sph2cart将球坐标值转换成直角坐标系下的坐标值，然后使用plot3、mesh等绘图命令。</p><blockquote><p>1).球坐标系(r,θ,φ)与<a href="https://baike.baidu.com/item/%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB?fromModule=lemma_inlink">直角坐标系</a>(x,y,z)的转换关系:&nbsp;[1]</p><p>x=rsinθcosφ.</p><p>y=rsinθsinφ.</p><p>z=rcosθ.</p><p>2).反之，直角坐标系(x,y,z)与球坐标系(r,θ,φ)的转换关系为:<br>$$<br>r = \sqrt{x<sup>2+y</sup>2+z^2}\<br>\theta = arccos\dfrac{z}{r}\<br>\phi = arctan\dfrac{y}{x}<br>$$</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><mark>[x,y,z] = sph2cart(azimuth,elevation,r)</mark>——azimuth为方位角，elevation为仰角，r为半径</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> theta = linspace(0,2*pi,20);fai = linspace(0,pi/2,20);r = 1;[x,y,z] = meshgrid(theta,fai,r);[X,Y,Z] = sph2cart(x,y,z);mesh(X,Y,Z)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F43.png" alt=""></p><h5 id="2-特殊二维图形的绘制">2.特殊二维图形的绘制</h5><ul class="lvl-0"><li class="lvl-2"><p><mark>bar(x,y)</mark>——<u>条形图</u>。x是横坐标，y是纵坐标</p></li><li class="lvl-2"><p><mark>fplot(y,[a b])</mark>——<u>精确绘图</u>。y代表某个函数，[a,b]表示需要精确绘图的范围</p></li><li class="lvl-2"><p><mark>polar(θ,r)</mark>——<u>极坐标图</u>。θ是角度，r代表以θ为变量的函数</p></li><li class="lvl-2"><p><mark>stairs(x,y)</mark>——<u>阶梯图</u>。x是横坐标，y是纵坐标</p></li><li class="lvl-2"><p><mark>line([x1,y1],[x2,y2],···)</mark>——<u>折线图</u>。[x1,y1]表示折现上的点</p></li><li class="lvl-2"><p><mark>fill(x,y,‘b’)</mark>——<u>实心图</u>。x是横坐标，y是纵坐标，‘b’代表颜色</p></li><li class="lvl-2"><p><mark>scatter(x,y,s,c)</mark>——<u>散点图</u>。s是圆圈标记点的面积，c是标记点的颜色</p></li><li class="lvl-2"><p><mark>pie(x)</mark>——<u>饼图</u>。x为向量</p></li><li class="lvl-2"><p><mark>contour(x)</mark>——<u>等高线</u>。x为向量</p></li><li class="lvl-2"><p><mark>errorbar(y,e)</mark>——<u>误差条</u>。y为数据点，e为误差范围</p></li><li class="lvl-2"><p><mark>hist(y)</mark>——<u>直方图</u>。y为矩阵</p></li><li class="lvl-2"><p><mark>quiver(x,y,dx,dy)</mark>——<u>向量图</u>。</p></li><li class="lvl-2"><p><mark>feather(x,y)</mark>——<u>向量图</u>。由向量参量x与y构成的速度参量，沿水平轴方向，从均匀间隔点发射出来</p></li><li class="lvl-2"><p><mark>feather(z)</mark>——<u>羽毛图</u>。参量z是一个复数，相当于<mark>compass(real(z),imag(z))</mark></p></li><li class="lvl-2"><p><mark>movie()</mark>——<u>建立动态二维图形</u>。</p></li></ul><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> x = [10 51 6 15 98 16 3 56];subplot(1,2,1)pie(x)hold on  y = [0 1 0 0 1 0 0 0];   切割饼图的操作subplot(1,2,2)pie(x,y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F44.png" alt=""></p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">>> M = rand(10000,3);hist(M)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fmatlab%2F45.png" alt=""></p><h4 id="9-5-三维绘图函数">9.5 三维绘图函数</h4><h4 id="9-5-1-绘制三维曲面">9.5.1 绘制三维曲面</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>surf()</mark></p></li><li class="lvl-2"><p><mark>surfc()</mark>——带等高线的surf函数</p></li><li class="lvl-2"><p><mark>surfl()</mark>——绘制具有亮面的曲面图</p></li><li class="lvl-2"><p><mark>shading faceted</mark>——在绘制曲面时采用分层网格线，为默认值</p></li><li class="lvl-2"><p><mark>shading flat</mark>——表示平滑式颜色分布方式；去掉黑色线条，补片保持单一颜色</p></li><li class="lvl-2"><p><mark>shading interp</mark>——表示插补式颜色分布方式；同样去掉线条，但补片以插值加色。这种方式需要比分块和平滑更多的计算量</p></li><li class="lvl-2"><p><mark>[x,y,z] = sphere(n)</mark>——绘制三维球面</p></li><li class="lvl-2"><p><mark>[x,y,z] = cylinder(R,n)</mark>——绘制三维柱面</p></li><li class="lvl-2"><p><mark>peaks()</mark>——多峰函数</p></li></ul><h4 id="9-5-2-栅格数据的生成">9.5.2 栅格数据的生成</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>meshgrid()</mark></p></li><li class="lvl-2"><p><mark>georasterref()</mark></p></li></ul><h4 id="9-5-3-网格曲面的绘制命令">9.5.3 网格曲面的绘制命令</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>plot3()</mark></p></li><li class="lvl-2"><p><mark>mesh()</mark></p></li><li class="lvl-2"><p><mark>meshc()</mark>——在绘图的同时，在x-y平面上绘制函数的等值线</p></li><li class="lvl-2"><p><mark>msehz()</mark>——在网格图的基础上在图形的底部外侧绘制平行z轴的边框线</p></li></ul><h4 id="9-5-4-隐藏线的显示和关闭">9.5.4 隐藏线的显示和关闭</h4><p><mark>hidden on</mark>——去掉网格曲面的隐藏线</p><p><mark>hidden off</mark>——显示网格曲面的隐藏线</p><h3 id="第十章-MATLAB图像处理算法">第十章 MATLAB图像处理算法</h3><h4 id="10-1-图像处理基础">10.1 图像处理基础</h4><p>1.图像增强</p><p>目前图像增强技术根据其处理的空间不同，可分为<mark>空域法</mark>和<mark>频域法</mark>两大类，前者根据在图像所在的像素空间进行处理，后者是通过对图像进行傅里叶变换后在频域空间上间接进行的。</p><p>2.图像重建</p><p>3.图像变换</p><p>4.图像压缩</p><p>5.图像分割</p><p>6.图像边缘检测</p><p>7.图像识别</p><h4 id="10-2-MATLAB图像处理函数">10.2 MATLAB图像处理函数</h4><h4 id="10-2-1-默认显示方式">10.2.1 默认显示方式</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>imshow(X,MAP)</mark>——显示图像X，使用MAP颜色矩阵</p></li><li class="lvl-2"><p>H = imshow(…)——显示图像X，并将图像X的句柄返回给变量H</p></li></ul><blockquote><p>imshow函数特点：</p><ol><li class="lvl-3"><p>自动设置图像的轴和标签属性。imshow程序代码会根据图像的特点，自动选择是否显示轴，或者是否显示标签属性。</p></li><li class="lvl-3"><p>自动设置是否显示图像的边框。程序代码会根据图像的属性，来自动选择是否显示图像的边框。</p></li><li class="lvl-3"><p>自动调用turesize代码程序，决定是否进行插值。</p></li></ol></blockquote><h4 id="10-2-2-添加颜色条">10.2.2 添加颜色条</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>colorbar</mark></p></li></ul><h4 id="10-2-3-显示多帧图像">10.2.3 显示多帧图像</h4><h4 id="10-2-4-显示动画">10.2.4 显示动画</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>movie</mark></p></li></ul><h4 id="10-2-5-三维材质图像">10.2.5 三维材质图像</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>warp(x,y,z,…)</mark>——在x、y、z三维界面上显示图像</p></li></ul><h4 id="10-2-6-图像的直方图">10.2.6 图像的直方图</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>imhist(I)</mark></p></li><li class="lvl-2"><p><mark>imhist(I,n)</mark></p></li><li class="lvl-2"><p><mark>imhist(X,map)</mark></p></li></ul><p>在以上的调用格式中，参数I表示灰度图或二值图，n为直方图的柱数，X表示索引图，map为对应的Colormap。在调用格式imhist(I,n)中，当n未指定时，n根据I的不同类型取256（灰度图）或2（二值图）。</p><h4 id="10-2-7-灰度变换">10.2.7 灰度变换</h4><p>灰度变换主要功能是改变图像的对比度。</p><ul class="lvl-0"><li class="lvl-2"><p><mark>imadjust</mark></p></li></ul><h4 id="10-2-8-均衡直方图">10.2.8 均衡直方图</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>histeq</mark></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/20230813/git-xue-xi-bi-ji/"/>
      <url>/20230813/git-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1><code>Git</code>学习笔记</h1><p>一个可以学习git的在线游戏：<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p><blockquote><p>参考资料：</p><p><a href="https://blog.csdn.net/JanuaryFM/article/details/120535660">Git使用教程（超详细）</a></p></blockquote><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F1.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F2.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F3.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F4.png" alt=""></p><h2 id="1-Git是什么">1. Git是什么</h2><p><strong>Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</strong></p><h2 id="2-Git安装-Windows">2. Git安装(Windows)</h2><ul class="lvl-0"><li class="lvl-4"><p>查看git版本信息</p><p><code>git --version</code></p></li></ul><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F5.png" alt=""></p><ul class="lvl-0"><li class="lvl-4"><p><mark>git配置</mark>（在使用用Git工作之前，我们需要做个一次性的配置。方便后续Git能跟踪到谁做了修改，我们需 要设置对应的用户名与邮箱地址。）</p></li></ul><p><code> git config --global user.name "your_username"</code><br><code> git config --global user.email your_email@domain.com</code><br><code> git config --list 查看所有配置</code></p><ul class="lvl-0"><li class="lvl-4"><p><strong>注意 git config 命令的 --global 参数，用了这个参数，表示你这台机器上所有的Git仓库都会 使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</strong></p></li></ul><h2 id="3-Git文件的三种状态和工作模式">3. Git文件的三种状态和工作模式</h2><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F6.png" alt=""></p><p><strong>针对Git 文件的三种状态，Git项目有三个工作区域:工作区、暂存区和Git仓库。</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F7.png" alt=""></p><p><strong>基本的Git工作流程描述如下：</strong></p><ul class="lvl-0"><li class="lvl-4"><p><strong>在工作区中修改某些文件。</strong></p></li><li class="lvl-4"><p><strong>对修改后的文件进行快照，然后添加到暂存区。</strong></p></li><li class="lvl-4"><p><strong>提交更新，将保存在暂存区域的文件快照永久转储到 Git 仓库中。</strong></p></li></ul><h2 id="4-创建版本仓库并提交文件">4. 创建版本仓库并提交文件</h2><p><strong>版本库又名仓库，可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来， 每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可 以“还原”。</strong></p><h3 id="4-1-初始化git仓库">4.1 初始化git仓库</h3><pre><code> 在本地文件自己指定位置，通过执行 git init 命令在本地初始化一个本地仓库，执行该命令后会在本地初始化一个 没有任何文件的空仓库。   `git init`   ps:&lt;u&gt;.git文件（本地仓库）是隐藏需要手动设置才能看到.git文件夹&lt;/u&gt;</code></pre><h3 id="4-2-在-git-同级目录下添加git01-txt-文件后，使用-git-status-查看工作目录与暂存区文件状态">4.2 在.git 同级目录下添加git01.txt 文件后，使用 git status 查看工作目录与暂存区文件状态</h3><pre><code> `git status 命令用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到 了, 哪些没有, 哪些文件没有被Git tracked（跟踪）到。`   ![](https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F8.png)</code></pre><h3 id="4-3-执行-git-add-文件名-命令添加文件到暂存区">4.3 执行 git add 文件名 命令添加文件到暂存区</h3><pre><code> `git add path 通常是通过git add &lt;path&gt;的形式把&lt;path&gt;添加到索引库中，&lt;path&gt;可以是文件也可以是目录。`   `git不仅能判断出&lt;path&gt;中，修改(不包括已删除)的文件，还能判断出新添的文件，并把它们的信息添加到索引库中。`   ![](https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F9.png)   &gt; `git add` 就好比如您去超市购物，用购物车装了一大车的商品（类似于修改过的文件），然后去收银台结账，由于您一次性挑选的商品比较多，你有可能要犹豫一下到底要不要全部买下来；这时候，你可以一件件的将商品拿到收银员那里去扫码计价结算（类似与` git add fileA`, `git add fileB`…，即添加指定某些文件）,也可以财大气粗的全部买下（类似于`git add .`/，即添加所有文件），接下来就是买单并拿回家（`git commit` 和 `git push`）。</code></pre><h3 id="4-4-提交文件到本地版本库（仓库）">4.4 提交文件到本地版本库（仓库）</h3><pre><code> **文件被添加到暂存区后，执行 git commit 命令提交暂存区文件到本地版本库中。**   `git commit 命令用于将更改记录(提交)到存储库。将索引的当前内容与描述更改的用户和 日志消息一起存储在新的提交中。通常在执行提交时 在 git commit 命令后跟上 -m 属性 加入本次提交的记录说明（注释）方便后续查看提交或改动记录。`   `git commit -m "注释"`   `git log`:用于显示提交日志信息</code></pre><h2 id="5-常用操作">5. 常用操作</h2><h3 id="5-1-修改git01-txt">5.1  <strong>修改git01.txt</strong></h3><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F10.png" alt=""></p><h3 id="5-2-git-status">5.2 <code>git status</code></h3><p><strong>此时当文件修改后 使用 git status 命令可以看到git 检测到文件被修改，git 版本库给出的下 一步操作是添加修改的文件到暂存区 此时执行添加操作命令</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F11.png" alt=""></p><h3 id="5-3-git-status">5.3 <code>git status</code></h3><p><strong>执行提交</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F12.png" alt=""></p><h3 id="5-4-git-log">5.4 <code>git log</code></h3><p><strong>git log 命令查看操作日志记录</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F13.png" alt=""></p><h3 id="5-5-git-commit">5.5 <code>git commit</code></h3><p><strong>执行提交操作</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F14.png" alt=""></p><h3 id="5-6-git-diff">5.6 <code>git diff</code></h3><p><strong>此时执行 git diff HEAD – git01.txt 与版本库内容进行比较结果如下:</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F15.png" alt=""></p><ul class="lvl-0"><li class="lvl-4"><blockquote><p>差异比较说明：</p><p><code>---</code>：表示变动前的文件</p><p><code>+++</code>：表示变动后的文件</p><p>变动的位置用两个@作为起首和结束</p><pre><code>@@ -1,2 +1,3 @@:减号表示第一个文件，"1"表示第1行，"2"表示连续2行。同样的，"+1,3"表示变动后，成为第二个文件从第1行开始的连续3行。</code></pre></blockquote></li></ul><h3 id="5-7-git-reset">5.7 <code>git reset</code></h3><p><strong>暂存区文件提交与撤销</strong></p><p>①`git reset head``</p><p>②<code>git checkout @{-1}</code></p><p><strong>当发现因失误而将文件添加到暂存区时，git 支持文件的撤销操作 执行命令git reset HEAD&nbsp;文件 操作如下:</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F16.png" alt=""></p><p><strong>查看版本库状态并执行撤销操作</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F17.png" alt=""></p><p><strong>再次查看版本库状态 test.txt 成为未追踪文件（撤销成功）</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F18.png" alt=""></p><h2 id="6-补充教程（复制粘贴）">6. 补充教程（复制粘贴）</h2><blockquote><p><a href="https://blog.csdn.net/wmz19960227/article/details/119153613">git使用大全_git 使用</a></p></blockquote><h3 id="6-1-版本的创建于回归">6.1 版本的创建于回归</h3><h4 id="1-基础使用">1. 基础使用</h4><p><code>git --help</code>——查看git所有指令</p><p><code>git init</code>——创建版本库</p><p><code>git add code.txt</code></p><p><code>git commit -m "版本1"</code>——创建一个版本</p><p><code>git log</code>——查看版本记录</p><p><code>git reset --hard HEAD~1</code>，<code>git checkout @{-1}</code>——<strong><u>回到上一个版本</u></strong></p><p><mark>HEAD表示当前最新版本</mark></p><blockquote><p>其中<code>HEAD</code>表示当前最新版本<code>HEAD^</code>表示当前版本的前一个版本、<code>HEAD^^</code>表示当前版本的前两个个版本;<br>也可以使用<code>HEAD~1</code>表示当前版本的前一个版本<code>HEAD~100</code>表示当前版本的前100版本。</p></blockquote><p><code>git reset --hard 版本号(Hash值)</code>——回到某个版本</p><p><code>git reflog</code>——<mark>查看操作记录</mark></p><h4 id="2-工作区和暂存区">2. 工作区和暂存区</h4><ul class="lvl-0"><li class="lvl-4"><p>git的版本库里存了很多东西，其中最重要的就是称为<mark>stage(或者叫index)的暂存区</mark>，还有git为我们自动创建的<mark>第一个分支master</mark>，以及<mark>指向master的一个指针叫HEAD</mark>。</p></li><li class="lvl-4"><p>因为我们创建git版本库时，git自动为我们创建了唯一一个master分支，所以，现在，git  commit就是往master分支上提交更改。</p></li><li class="lvl-4"><p><strong><u>可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改</u></strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F19.png" alt=""></p></li><li class="lvl-4"><p>前面讲了我们把文件往git版本库里添加的时候，是分两步执行的：</p></li></ul><blockquote><ol><li class="lvl-3"><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p></li><li class="lvl-3"><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p></li></ol></blockquote><ul class="lvl-0"><li class="lvl-4"><p>使用<code>git status</code>命令查看当前工作树的状态</p><ul class="lvl-2"><li class="lvl-6"><p>如果工作区和暂存区不一致时</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F20.png" alt=""></p></li><li class="lvl-6"><p>如果所有文件都被提交到了版本库</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F21.png" alt=""></p></li></ul></li></ul><h4 id="3-撤销修改">3. 撤销修改</h4><ul class="lvl-0"><li class="lvl-4"><p>场景1：当你<strong>改乱了工作区某个文件的内容，想直接丢弃工作区的修改</strong>时，用命令<code>git checkout – file</code></p></li><li class="lvl-4"><p>场景2：当你<strong>不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改</strong>，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作</p></li></ul><h4 id="4-对比工作区文件与HEAD版本中文件的不同">4. 对比工作区文件与HEAD版本中文件的不同</h4><p><code>(HEAD表示当前.git库中</code>的最新版本)</p><p><code>git diff HEAD -- code.txt</code></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F22.png" alt=""></p><h5 id="①-查看工作区和暂存区之间文件的差异">① 查看工作区和暂存区之间文件的差异</h5><blockquote><p><code>git diff</code> 命令，默认查看的就是 工作区 和 暂存区之间文件的差异</p><p>1.<code>git diff</code> : 查看工作区和暂存区之间所有的文件差异<br>2.<code>git diff -- 文件名</code>：查看具体某个文件 在工作区和暂存区之间的差异<br>3.<code>git diff -- 文件名1 文件名2 文件名3</code>：查看多个文件在工作区和暂存区之间的差异【注意】：查看具体文件的时候 – 和文件名 之间有一个 空格,文件名1 和 文件名2 和 文件名3之间也有空格</p></blockquote><p><strong>1.初始条件：工作区，暂存区之间保持干净一致的状态</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F23.png" alt=""></p><p><strong>2.修改工作区中的文件</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F24.png" alt=""></p><p><strong>3.<code>git diff -- 文件名1 文件名2</code>&nbsp;查看文件的差异</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F25.png" alt=""></p><p><strong>4.扩展：将工作区中修改的文件添加到暂存区后再比较差异情况</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F26.png" alt=""></p><h5 id="②-查看工作区和版本库之间文件的差异">② 查看工作区和版本库之间文件的差异</h5><blockquote><p><code>git diff HEAD</code> : 查看工作区与最新版本库之间的所有的文件差异<br><code>git diff 具体某个版本</code> : 查看工作区与具体某个提交版本之间的所有的文件差异<br><code>git diff HEAD -- 文件名</code> ： 查看工作区与最新版本库之间的 指定文件名的文件差异<br><code>git diff HEAD -- 文件名1 文件名2 文件名3</code> ：查看工作区与最新版本库之间的 指定文件名的多个文件差异<br><code>git diff 具体某个版本 -- 文件名</code> ： 查看工作区与具体某个版本之间的 指定文件名的文件差异<br><code>git diff 具体某个版本 -- 文件名1 文件名2 文件名3</code> ：查看工作区与最具体某个版本之间的 指定文件名的多个文件差异</p></blockquote><p><strong>1.初始条件：</strong></p><blockquote><p><code>9f5a54b</code>版本只新增了五个文件:a.txt、 b.txt 、c.txt 、d.txt、 e.txt<br><code>da27f42</code>&nbsp;版本修改了 a.txt 和 b.txt 两个文件<br>当前工作区、暂存区、版本库状态一致</p></blockquote><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F27.png" alt=""></p><p><strong>2.再修改一下 a.txt 文件内容</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F28.png" alt=""></p><p><strong>3.查看当前工作区 和&nbsp;<code>9f5a54b</code>版本直接的文件差异</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F29.png" alt=""></p><h5 id="③情景三：查看暂存区和版本库之间文件的差异">③情景三：查看暂存区和版本库之间文件的差异</h5><blockquote><p>》官方文档写的就非常的好！</p><p><code>git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…​]</code></p><p>This form is to view the changes you staged for the next commit relative to the named <commit>.<br>Typically you would want comparison with the latest commit, so if you do not give <commit>, it defaults to HEAD.<br>If HEAD does not exist (e.g. unborn branches) and <commit> is not given, it shows all staged changes.<br>–staged is a synonym of --cached.</commit></commit></commit></p><p>》 下面是我自己的译文：此命令 用于查看 暂存区中和 指定提交 之间的文件差异。特别指出：你可能最想比较暂存区与上一次提交之间的区别，所以，如果你不明确指定 提交的版本号，则默认是HEAD.<br>如果 HEAD 和 指定版本号都不存在，则该命令会展示暂存区中所有的修改。<br>–staged 参数和 --cached 参数是一致的。</p></blockquote><blockquote><p><strong>git diff --cached</strong> : 查看暂存区和 上一次提交 的最新版本(HEAD)之间的所有文件差异<br><strong>git diff --cached 版本号 ： 查看暂存区和 指定版本 之间的所有文件差异<br>git diff --cached – 文件名1 文件名2 文件名3</strong> ： 查看暂存区和 HEAD 之间的指定文件差异<br><strong>git diff --cached 版本号 – 文件名1 文件名2 文件名3</strong> ： 查看暂存区和 指定版本 之间的指定文件差异1</p></blockquote><p><strong>1.初始条件：</strong></p><blockquote><p><code>9f5a54b</code>版本只新增了五个文件:a.txt、 b.txt 、c.txt 、d.txt、 e.txt<br><code>da27f42</code>&nbsp;版本修改了 a.txt 和 b.txt 两个文件<br><code>f0c63af</code>&nbsp;版本修改了 a.txt 文件<br>当前工作区、暂存区、版本库状态一致</p></blockquote><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F30.png" alt=""></p><p><strong>2.修改文件，并添加到暂存区</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F31.png" alt=""></p><p><strong>3.查看暂存区与上个提交版本之间的区别</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F32.png" alt=""></p><p><strong>4.查看暂存区与具体某个版本之间的区别</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F33.png" alt=""></p><h5 id="④-查看不同版本库之间文件的差异">④ 查看不同版本库之间文件的差异</h5><blockquote><p><code>git diff 版本号1 版本号2</code> ： 查看两个版本之间的差异<br><code>git diff 版本号1 版本号2 -- 文件名1 文件名2</code> ： 查看两个版本之间的指定文件之间的差异<br><code>git diff 版本号1 版本号2 --stat</code> : 查看两个版本之间的改动的文件列表<br><code>git diff 版本号1 版本号2 src</code> : 查看两个版本之间的文件夹 src 的差异</p></blockquote><p><strong>1.<mark>查看当前的版本列表</mark></strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F34.png" alt=""></p><p><strong>2.查看两个版本之间的差异</strong></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F35.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F36.png" alt=""></p><h4 id="5-删除文件">5. 删除文件</h4><ul class="lvl-0"><li class="lvl-4"><p><code>git rm code.txt</code></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F37.png" alt=""></p></li><li class="lvl-4"><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容</p></li></ul><h3 id="6-2-分支管理">6.2 分支管理</h3><h4 id="1-创建和合并分支">1. 创建和合并分支</h4><ul class="lvl-0"><li class="lvl-4"><p>git把我们之前每次提交的版本串成一条时间线，这条时间线就是一个分支。截止到目前只有一条时间线，<strong><u>在git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支</u></strong></p></li><li class="lvl-4"><p>一开始的时候，master分支是一条线，git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F38.png" alt=""></p><ul class="lvl-2"><li class="lvl-6"><p>git创建一个分支很快，因为除了增加一个dev指针，改变HEAD的指向，工作区的文件都没有任何变化。</p></li></ul></li><li class="lvl-4"><p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F39.png" alt=""></p></li><li class="lvl-4"><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F40.png" alt=""></p><p>git合并分支也很快，就改改指针，工作区内容也不变。</p></li><li class="lvl-4"><p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F41.png" alt=""></p></li></ul><h4 id="2-创建和合并分支举例">2. 创建和合并分支举例</h4><ul class="lvl-0"><li class="lvl-4"><p>执行如下命令可以查看当前有几个分支并且看到在哪个分支下工作</p><p><code>git branch</code></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F42.png" alt=""></p></li><li class="lvl-4"><p><mark>创建一个分支dev并切换到其上进行工作</mark></p><p><code>git checkout -b dev</code></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F43.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F44.png" alt=""></p></li><li class="lvl-4"><p>修改code.txt内容，在里面添加一行，并进行提交</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F45.png" alt=""></p></li><li class="lvl-4"><p><mark>切换回master分支</mark></p><p><code>git checkout master</code></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F46.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F47.png" alt=""></p><p><strong>查看code.txt，发现添加的内容没有了。<mark>因为那个提交是在dev分支上</mark>，而master分支此刻的提交点并没有变</strong></p></li><li class="lvl-4"><p><mark>把dev分支的工作成果合并到master分支上</mark></p><p><code>git merge 分支名称</code></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F48.png" alt=""></p><p>再查看code.txt的内容，就可以看到，和dev分支的最新提交是完全一样的</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F49.png" alt=""></p><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快</p></li><li class="lvl-4"><p>合并完成后，就可以放心地<mark>删除dev分支</mark>了，删除后，查看branch，就只剩下master分支了</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F50.png" alt=""></p></li></ul><p>总结：</p><blockquote><p><strong><mark>查看分支：git branch</mark><br><mark>创建分支：git branch <name></name></mark><br><mark>切换分支：git checkout <name></name></mark><br><mark>创建+切换分支：git checkout -b <name></name></mark><br><mark>合并某分支到当前分支：git merge <name></name></mark><br><mark>删除分支：git branch -d <name></name></mark></strong></p></blockquote><h4 id="3-解决冲突">3. 解决冲突</h4><ul class="lvl-0"><li class="lvl-4"><p>master分支和dev分支各自都分别有新的提交：</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F51.png" alt=""></p></li><li class="lvl-4"><p>执行如下命令尝试将dev分支合并到master分支上来</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F52.png" alt=""></p></li><li class="lvl-4"><p><code>git status</code>也可以告诉我们冲突的文件</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F53.png" alt=""></p></li><li class="lvl-4"><p>查看code.txt的内容</p><p><code>cat &lt;文件名&gt;</code></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F54.png" alt=""></p></li><li class="lvl-4"><p><mark>git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存</mark></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F55.png" alt=""></p></li><li class="lvl-4"><p>再提交</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F56.png" alt=""></p></li><li class="lvl-4"><p>现在，master分支和dev分支变成了下图所示</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F57.png" alt=""></p></li><li class="lvl-4"><p>用带参数的git log也可以看到分支的合并情况</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F58.png" alt=""></p></li></ul><h4 id="4-分支管理策略">4. 分支管理策略</h4><p><strong>通常，合并分支时，如果可能，git会用fast forward模式</strong></p><p><strong>但是有些快速合并不能成功而且合并时没有冲突，这个时候会合并之后并做一次新的提交</strong></p><p><strong>但这种模式下，删除分支后，会丢掉分支信息</strong></p><ul class="lvl-0"><li class="lvl-4"><p>创建切换到dev分支下；</p></li><li class="lvl-4"><p>新建一个文件code3.txt编辑内容，并提交一个commit；</p></li><li class="lvl-4"><p>切换回master分支，编辑code.txt并进行一个提交；</p></li><li class="lvl-4"><p>合并dev分支的内容到master分支；</p></li><li class="lvl-4"><p>出现如下提示，这是因为这次不能进行快速合并，所以git提示输入合并说明信息，输入合并内容之后git会自动创建一次新的提交</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F59.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F60.png" alt=""></p></li><li class="lvl-4"><p><strong>如果要强制禁用fast forward模式，git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</strong></p></li><li class="lvl-4"><p>创建并切换到dev分支；</p></li><li class="lvl-4"><p>修改code.txt内容，并提交一个commit；</p></li><li class="lvl-4"><p>切换回master分支；</p></li><li class="lvl-4"><p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward；</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F61.png" alt=""></p><p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去</p></li><li class="lvl-4"><p>合并后，我们用git log看看分支历史</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F62.png" alt=""></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F63.png" alt=""></p></li></ul><h4 id="5-bug分支">5. bug分支</h4><p><strong>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除</strong></p><ul class="lvl-0"><li class="lvl-4"><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，恢复工作现场</p></li></ul><h3 id="6-3-使用github">6.3 使用github</h3><h4 id="1-创建仓库">1. 创建仓库</h4><ul class="lvl-0"><li class="lvl-4"><p>注册github账户，登录后，点击"New respository "</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F64.png" alt=""></p></li><li class="lvl-4"><p>在新页面中，输入项目的名称，勾选’<a href="http://readme.md">readme.md</a>’，点击’create repository’</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F65.png" alt=""></p></li><li class="lvl-4"><p>添加成功后，转到文件列表页面</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F66.png" alt=""></p></li></ul><h4 id="2-添加ssh账户">2. 添加ssh账户</h4><ul class="lvl-0"><li class="lvl-4"><p>点击账户头像后的下拉三角，选择’settings’（如果某台机器需要与github上的仓库交互，那么就要把这台机器的ssh公钥添加到这个github账户上）；</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F67.png" alt=""></p></li><li class="lvl-4"><p>点击’SSH and GPG keys’，添加ssh公钥。</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F68.png" alt=""></p></li><li class="lvl-4"><p>编辑文件.gitconfig，修改某台机器的git配置</p></li><li class="lvl-4"><p>修改为注册github时的邮箱，填写用户名</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F69.png" alt=""></p></li><li class="lvl-4"><p>使用如下命令生成ssh密钥&nbsp;<code>ssh-keygen -t rsa -C "邮箱地址"</code></p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F70.png" alt=""></p></li><li class="lvl-4"><p>进入主目录下的.ssh文件件，下面有两个文件</p><pre><code> 公钥为id_rsa.pub 私钥为id_rsa</code></pre></li><li class="lvl-4"><p>查看并复制公钥内容</p></li><li class="lvl-4"><p>回到浏览器中，填写标题，粘贴公钥</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F71.png" alt=""></p></li></ul><h4 id="3-克隆项目">3. 克隆项目</h4><ul class="lvl-0"><li class="lvl-4"><p>复制git地址</p><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F72.png" alt=""></p></li></ul><h4 id="4-推送项目">4. 推送项目</h4><ul class="lvl-0"><li class="lvl-4"><p>推送分支，就是把该分支上的所有本地提交推送到远程库，推送时要指定本地分支，这样，git就会把该分支推送到远程库对应的远程分支上</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">git push origin 分支名称例：git push origin smart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><mark>git第一次提交出现fatal</mark>: No configured push destination. Either specify the URL from the command-line or</p><p><strong>1. 需要在 git push 之前需要输入 git remote add origin “远程仓库地址”</strong></p><pre class="line-numbers language-language-git"><code class="language-language-git">git remote add origin https://gitee.com/liujianzhuang/js-basics.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2. git push -u origin 对应远程分支名</strong></p><pre class="line-numbers language-language-git"><code class="language-language-git">git push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3. 接下来就可以直接一套操作了</strong></p><pre class="line-numbers language-language-git"><code class="language-language-git">git add .git commit -m "信息"git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-将本地分支跟踪服务器分支">5. 将本地分支跟踪服务器分支</h4><pre class="line-numbers language-language-md"><code class="language-language-md">git branch --set-upstream-to=origin/远程分支名称 本地分支名称例：git branch --set-upstream-to=origin/smart smart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F73.png" alt=""></p><h4 id="6-从远程分支上拉去代码">6. 从远程分支上拉去代码</h4><pre class="line-numbers language-language-md"><code class="language-language-md">git pull orgin 分支名称例：git pull orgin smart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/blog%2Flazyload-loading.gif" data-original="https://bucket1-1319772612.cos.ap-shanghai.myqcloud.com/pic-notes%2Fgit%2F74.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必备工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记</title>
      <link href="/20230813/python-xue-xi-bi-ji/"/>
      <url>/20230813/python-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><strong>笔记参考教程：（python蛇书）Python编程 从入门到时间（第2版）（ [美]埃里克 · 马瑟斯 著 袁国忠 译 ）</strong></p><p><strong>此文章为个人学习笔记，仅供学习交流，不作商业用途，如果侵权，请联系站长删除</strong></p><h1>Python学习笔记</h1><h2 id="1-变量和简单数据类型">1.变量和简单数据类型</h2><h3 id="1-1字符串">1.1字符串</h3><pre class="line-numbers language-language-python"><code class="language-language-python">单引号和双引号都可以“This is a string“'This is also a string'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-1-1“方法”">1.1.1“方法”</h4><p>方法后面的 “ ( ) ” 是由于某些方法通常需要额外的信息来完成其工作</p><ul class="lvl-0"><li class="lvl-2"><p><mark>title()</mark>——每个单词首字母大写</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">  names = "ada lovelace"  print(names.title())  ------  #输出得  Ada Lovelace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>upper()</mark>——全大写</p></li><li class="lvl-2"><p><mark>lower()</mark>——全小写</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = "ada lovelace"print(names.upper())print(names.lower())------#输出得ADA LOVELACEada lovelace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-2变量">1.1.2变量</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>{}</mark></p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">first_name = "ada"last_name = "lovelace"full_name = f"{first_name} {last_name}"print(full_name)------#输出得ada lovelace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">first_name = "ada"last_name = "lovelace"full_name = f"{first_name} {last_name}"print(f"Hello,{full_name.title()}!")------#输出得Hello,Ada LoveLace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-3删除空白">1.1.3删除空白</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>rstrip()</mark>——删除字符后面的空</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">>>>favorite_language = 'python '>>>favorite_language'python '>>>favorite_language.rstrip()'python'>>>favorite_language'python '<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>lstrip()</mark>——删除字符前面的空</p></li><li class="lvl-2"><p><mark>strip()</mark>——删除字符前后的空</p></li></ul><h3 id="1-2数">1.2数</h3><ul class="lvl-0"><li class="lvl-2"><p>任意两个数相除，结果总是浮点数，即使这两个数都是整数且能整除</p></li><li class="lvl-2"><p>下划线——书写很大的数用下划线区分数字分组，使其清晰易读。当打印这种带下划线的数时，Python不会打印其中的下划线</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">>>>num = 12_000_000_000>>>print(num)12000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>同时给多个变量赋值</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">x,y,z = 10,20,30<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-列表">2.列表</h2><h3 id="2-1列表是什么">2.1列表是什么</h3><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['joe','zero','kent','peter']print(names)print(names[0])message = 'names[0].title() is a good friend.'print(message)print(f"{names[0].title()} is a good friend.")------#输出得['joe', 'zero', 'kent', 'peter']joename[0].title() is a good friend.Joe is a good friend.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果直接让Python将列表打印出来，Python将打印列表的内部表示，包括方括号</p><h3 id="2-2修改、添加和删除列表元素">2.2修改、添加和删除列表元素</h3><h4 id="2-2-1修改">2.2.1修改</h4><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['joe','zro','kent','peter']print(names)names[0] = 'luffy'print(names)------#输出得['joe', 'zero', 'kent', 'peter']['luffy', 'zero', 'kent', 'peter']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2添加">2.2.2添加</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>append()</mark>——在列表末尾添加元素</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp','sanji']names.append('nami')print(names)------#输出得['luffy', 'zoro', 'usopp', 'sanji', 'nami']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>insert()</mark>——在列表中插入元素</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp','sanji']names.insert(1,'shanks')print(names)------#输出得['luffy', 'shanks', 'zoro', 'usopp', 'sanji']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3删除">2.2.3删除</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>del</mark>——永久删除</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp','sanji']print(names)del names[0]print(names)------#输出得['luffy', 'zoro', 'usopp', 'sanji']['zoro', 'usopp', 'sanji']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>pop()</mark>——若括号中无值，则默认取出最后一个元素；否则，取出指定位置的元素</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp','sanji']print(names)person1 = names.pop()person2 = names.pop(0)print(names)print(person1)print(person2)------#输出得['luffy', 'zoro', 'usopp', 'sanji']['zoro', 'usopp']sanjiluffy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>remove()</mark>——删除指定值的元素</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp','sanji']print(names)names.remove('usopp')print(names)------#输出得['luffy', 'zoro', 'usopp', 'sanji']['luffy', 'zoro', 'sanji']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3排序">2.3排序</h3><ul class="lvl-0"><li class="lvl-2"><p><mark>print(-1)</mark>——打印倒数第一个元素</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp','sanji']print(names[-1])print(names[-2])------#输出得sanjiusopp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>sort()</mark>——按字母顺序永久排列</p></li><li class="lvl-2"><p>sort(reverse = True)——按字母反序排列</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp','sanji']print(names)names.sort()print(names)names.sort(reverse=True)print(names)------#输出得['luffy', 'zoro', 'usopp', 'sanji']['luffy', 'sanji', 'usopp', 'zoro']['zoro', 'usopp', 'sanji', 'luffy']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>sorted()</mark>——临时排列</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp','sanji']print(sorted(names))print(names)------#输出得['luffy', 'sanji', 'usopp', 'zoro']['luffy', 'zoro', 'usopp', 'sanji']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>reverse()</mark>——反转列表元素顺序</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp','sanji']names.reverse()print(names)------#输出得['sanji', 'usopp', 'zoro', 'luffy']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>len()</mark>——确定列表长度</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp','sanji']length = lennames)print(length)------#输出得4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4遍历">2.4遍历</h3><ul class="lvl-0"><li class="lvl-2"><p>python中<mark>for循环</mark>语法：对于列表中的每个元素，都将执行循环指定的步骤，而不管列表包含多少个元素</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">for 变量 in 序列:  # 循环体语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>尤其注意，针对for循环，必须保证其循环后指定的步骤有相同的缩进</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp']for name in names:    print(f'{name.title()} is a character in OnePiece.')    print('And I like him/her.\n')------#输出得Luffy is a character in OnePiece.And I like him/her.Zoro is a character in OnePiece.And I like him/her.Usopp is a character in OnePiece.And I like him/her.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','usopp']for name in names:    print(f'{name.title()} is a character in OnePiece.')print('And I like him/her.\n')------#输出得Luffy is a character in OnePiece.Zoro is a character in OnePiece.Usopp is a character in OnePiece.And I like him/her.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5创建列表">2.5创建列表</h3><h4 id="2-5-1使用函数range-list-append">2.5.1使用函数range/list/append</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>rang()</mark>——生成一系列数。</p><p>e.g：range(1,5)只生成1至4，从1开始，到5结束，所以未生成5</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">for value in range(1,5)    print(value)------1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定步长的range()</p><p>range(1,11,3)：从1至11，步长为3</p><pre class="line-numbers language-language-python"><code class="language-language-python">for numb in range(1,11,3):    print(numb)------14710<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>list()</mark>——生成列表</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">numbs1 = range(1,5)print(numbs1)numbs2 = list(range(1,5))print(numbs2)------range(1, 5)[1, 2, 3, 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>append()</mark>生成列表</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">numbs = []for a in range(1,6):    numbs.append(a**2)print(numbs)------[1, 4, 9, 16, 25]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<mark>**</mark>表示乘方运算</p><h4 id="2-5-2列表解析">2.5.2列表解析</h4><pre class="line-numbers language-language-python"><code class="language-language-python">numbs = [a**2 for a in range(1,11,3)]print(numbs)------[1, 16, 49, 100]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6对数字列表进行统计运算">2.6对数字列表进行统计运算</h3><ol><li class="lvl-3"><p>内置函数：</p><ul class="lvl-2"><li class="lvl-5"><code>len()</code>：返回列表的长度（元素个数）。</li><li class="lvl-5"><code>sum()</code>：返回列表中所有元素的和。</li><li class="lvl-5"><code>min()</code>：返回列表中的最小值。</li><li class="lvl-5"><code>max()</code>：返回列表中的最大值。</li><li class="lvl-5"><code>sorted()</code>：返回一个排好序的列表副本。</li></ul></li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">numbers = [3, 5, 1, 2, 4]length = len(numbers)total = sum(numbers)minimum = min(numbers)maximum = max(numbers)sorted_numbers = sorted(numbers)print(length)           # 输出：5print(total)            # 输出：15print(minimum)          # 输出：1print(maximum)          # 输出：5print(sorted_numbers)   # 输出：[1, 2, 3, 4, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li class="lvl-3"><p>统计库 -&nbsp;<code>statistics</code>：<br><code>statistics</code>&nbsp;是Python的标准库之一，提供了执行统计计算的函数，如平均值、标准差、中位数等。需要导入&nbsp;<code>statistics</code>&nbsp;模块才能使用。</p></li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">import statisticsnumbers = [3, 5, 1, 2, 4]mean = statistics.mean(numbers)        # 平均值median = statistics.median(numbers)    # 中位数stdev = statistics.stdev(numbers)      # 标准差variance = statistics.variance(numbers)# 方差print(mean)         # 输出：3.0print(median)       # 输出：3print(stdev)        # 输出：1.5811388300841898print(variance)     # 输出：2.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7列表切片">2.7列表切片</h3><h4 id="2-7-1切片">2.7.1切片</h4><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','sanji','usopp','nami']print(names[0:3])     #从0号元素开始，到3号元素终止print(names[2:])      #从2号元素开始，到列表末尾所有元素print(names[:3])      #从列表开始开始，终止到3号元素print(names[-3:])     #从倒数第三个元素开始，到列表末尾所有元素print(names[:])       #从列表开头到列表末尾的所有元素------['luffy', 'zoro', 'sanji']['sanji', 'usopp', 'nami']['luffy', 'zoro', 'sanji']['sanji', 'usopp', 'nami']['luffy', 'zoro', 'sanji', 'usopp', 'nami']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-2遍历切片">2.7.2遍历切片</h4><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','sanji','usopp','nami']for name in names[:3]:    print(name.title())------LuffyZoroSanji<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-3复制列表">2.7.3复制列表</h4><ol><li class="lvl-3"><p>先看 <strong><mark>names_1 = names[:]</mark></strong> 的情况</p></li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','sanji','usopp','nami']names_1 = names[:]print(f'names_1 = {names_1}')names.append('x')names_1.append('y')print(f'names_appended = {names}')print(f'names_1_appended = {names_1}')------names_1 = ['luffy', 'zoro', 'sanji', 'usopp', 'nami']names_appended = ['luffy', 'zoro', 'sanji', 'usopp', 'nami', 'x']names_1_appended = ['luffy', 'zoro', 'sanji', 'usopp', 'nami', 'y']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li class="lvl-3"><p>再来观察直接赋值的情况 <strong><mark>names_1 = names</mark></strong> ，<mark>这种用法是错误的</mark></p></li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">names = ['luffy','zoro','sanji','usopp','nami']names_2 = namesprint(f'names_2 = {names_2}')names.append('x')names_2.append('y')print(f'names_appended = {names}')print(f'names_2_appended = {names_2}')------names_2 = ['luffy', 'zoro', 'sanji', 'usopp', 'nami']names_appended = ['luffy', 'zoro', 'sanji', 'usopp', 'nami', 'x', 'y']names_2_appended = ['luffy', 'zoro', 'sanji', 'usopp', 'nami', 'x', 'y']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，情况2的names_2实则就是names，而names_1才是names的副本。</p><p><u>即<strong>names_1</strong>是在<strong>names</strong>的基础上衍生出的一个新变量，而<strong>names_2</strong>只是与<strong>names</strong>相关联，可理解为<strong>names_2</strong>指向<strong>names</strong>。</u></p><h3 id="2-8元组">2.8元组</h3><blockquote><p><u>列表是可变的，而元组是不可变的，但用来存储元组的变量是可以变的。</u></p><p>元组很像列表，<u>但是元组使用<strong>圆括号</strong>而非<strong>中括号</strong>来标识</u>。访问元组的过程同列表。</p><p>严格来说，<strong><u>元组是由逗号标识的</u></strong>，圆括号只是为了让元组看起来更加整洁和清晰。<mark>如果要定义一个只包含一个元素的元组，必须在这个元素的后面加上逗号</mark>。</p></blockquote><pre class="line-numbers language-language-python"><code class="language-language-python">numbs = (1123,118)print(numbs[0])print(numbs[1])------1123118<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark>若要尝试修改元组的值，则会产生报错</mark></p><pre class="line-numbers language-language-python"><code class="language-language-python">numbs = (1123,118)numbs[0] = [666]------Traceback (most recent call last):  File "d:\Study\extracurricular\Python\temp.py", line 2, in <module>    numbs[0] = [666]    ~~~~~^^^TypeError: 'tuple' object does not support item assignment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark>但修改元组变量指向的值是可以的</mark></p><pre class="line-numbers language-language-python"><code class="language-language-python">numbs = (1123,118)print(numbs)numbs = (1123,)print(numbs)------(1123, 118)(1123,)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-if语句">3.if语句</h2><ul class="lvl-0"><li class="lvl-2"><p>通用语法</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">if 条件:    # 满足条件时执行的代码块else:    # 不满足条件时执行的代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">if 条件1:    # 满足条件1时执行的代码块elif 条件2:    # 满足条件2时执行的代码块elif 条件3:    # 满足条件3时执行的代码块else:    # 所有条件都不满足时执行的代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>and</mark>&nbsp;&nbsp;&nbsp;&nbsp;如果你想要检查多个条件都为真，你可以使用 “and” 运算符。例如：</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">if 条件1 and 条件2:    # 当条件1 和 条件2 都为真时执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>or</mark>&nbsp;&nbsp;&nbsp;&nbsp;如果你想要检查多个条件中至少一个为真，你可以使用 “or” 运算符。例如：</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">if 条件1 or 条件2:    # 当条件1 或 条件2 其中一个为真时执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>此外，你还可以结合使用括号来明确条件的组合关系。例如：</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">if (条件1 and 条件2) or 条件3:    # 当条件1 和 条件2 都为真，或者条件3为真时执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>in</mark>&nbsp;&nbsp;&nbsp;&nbsp;要检查特定值是否<strong>包含</strong>在列表中，你可以使用&nbsp;<code>in</code>&nbsp;运算符。示例如下：</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">my_list = [1, 2, 3, 4, 5]if 3 in my_list:    # 当列表中包含值为 3 时执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>not in</mark>&nbsp;&nbsp;&nbsp;&nbsp;如果要检查特定值是否<strong>不包含</strong>在列表中，你可以使用&nbsp;<code>not in</code>&nbsp;运算符。示例如下：</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">my_list = [1, 2, 3, 4, 5]if 6 not in my_list:    # 当列表中不包含值为 6 时执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>布尔表达式</mark></p></li></ul><p>布尔表达式是一种逻辑表达式，用于在编程中表示条件判断的结果。布尔表达式的结果只能是两个值之一：True（真）或 False（假）。</p><p>布尔表达式通常使用比较运算符（如相等、大于、小于等）和逻辑运算符（如与、或、非等）进行构建，它们用于比较值、执行逻辑操作和连接多个条件。</p><pre class="line-numbers language-language-python"><code class="language-language-python">Luffy = 'Pirate King'print("Is Luffy  the 'Pirate King'?I predict True!")print("Luffy == 'Pirate King'")     #print中为普通语句print(Luffy == 'Pirate King')       #print中为布尔表达式------Is Luffy  the 'Pirate King'?I predict True!Luffy == 'Pirate King'True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-字典">4.字典</h2><p><strong>字典</strong>是一系列<strong>键值对</strong>，每个键都与一个值相关联。</p><h3 id="4-1访问字典中的值">4.1访问字典中的值</h3><pre class="line-numbers language-language-python"><code class="language-language-python">NikaMan = {'name': 'Luffy', 'gender': 'man','age':19 }print(f'Nikaman is a {NikaMan["gender"]}.)------Nikaman is a man.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2添加键值对">4.2添加键值对</h3><pre class="line-numbers language-language-python"><code class="language-language-python">NikaMan = {'name': 'Luffy', 'gender': 'man'}print(NikaMan)NikaMan['age'] = 19print(NikaMan)------{'name': 'Luffy', 'gender': 'man'}{'name': 'Luffy', 'gender': 'man', 'age': 19}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3删除键值对">4.3删除键值对</h3><ul class="lvl-0"><li class="lvl-2"><p><mark>del NikaMan[‘age’]</mark></p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">NikaMan = {'name': 'Luffy', 'gender': 'man','age': 19}print(NikaMan)del NikaMan['age']print(NikaMan)------{'name': 'Luffy', 'gender': 'man', 'age': 19}{'name': 'Luffy', 'gender': 'man'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4字典另一种表达形式">4.4字典另一种表达形式</h3><pre class="line-numbers language-language-python"><code class="language-language-python">favorite_language = {    'lixiang': 'python',    'z': 'c',    'kaifeng': 'cpp',    'lxq': 'java'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：每行后面的<mark>逗号 ‘,’ 不能掉</mark></strong></p><h3 id="4-5使用get-来访问值">4.5使用get()来访问值</h3><p><strong>方法get()的第一个参数用来用于指定键，第二个参数为指定键不存在时要返回的值，是可选的。</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">favorite_language = {    'lixiang': 'python',    'z': 'c',    'kaifeng': 'cpp',    'lxq': 'java'}print(favorite_language.get('ncc','No such key'))print(favorite_language.get('ncc'))print(favorite_language.get('lxq','Can not find'))------No such keyNone       java  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6遍历字典">4.6遍历字典</h3><ul class="lvl-0"><li class="lvl-2"><p><code>key</code>字典中的键</p></li><li class="lvl-2"><p><code>value</code>字典中的值</p></li><li class="lvl-2"><p><code>items()</code>是<mark>字典对象</mark>的方法</p></li><li class="lvl-2"><p><code>keys()</code>是<mark>访问字典键</mark>的方法</p></li><li class="lvl-2"><p><code>value()</code>是<mark>访问字典值</mark>的方法</p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">Person = {'name': 'Z', 'gender': 'man', 'age': 20, 'PhoneNumbe':123456 }for key,value in Person.items():    print(key,value)------name Zgender man       age 20PhoneNumbe 123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<u>key和value不是一定的，只是一个命名</u>，为了便于理解，可以用其他的命名方式，如下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">favorite_language = {    'Z': 'C',    'lx': 'Python',    'lxq': 'cpp',    'zkf': 'Java'}for name,language in favorite_language.items():    print(f"{name.title()}'s language is {language}")------Z's language is C      Lx's language is PythonLxq's language is cpp  Zkf's language is Java <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问字典键和字典值的方法如下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">favorite_language = {    'Z': 'C',    'lx': 'Python',    'lxq': 'cpp',    'zkf': 'Java'}if 'ncc' not in favorite_language.keys():    print("NCC is not a key in favorite_language")if 'Java' in favorite_language.values():    print("Somebody likes Java.")------NCC is not a key in favorite_languageSomebody likes Java.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">favorite_language = {    'Z': 'C',    'lx': 'Python',    'lxq': 'cpp',    'zkf': 'Java'}keys = sorted(favorite_language.keys(),reverse = Ture)for key in keys:    print(key.title())------ZkfLxqLxZ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-7嵌套">4.7嵌套</h3><h4 id="4-7-1在列表中存储字典">4.7.1在列表中存储字典</h4><pre class="line-numbers language-language-python"><code class="language-language-python">## Make an empty list for storing aliens.aliens = []## Make 30 green aliens.for alien_number in range(30):    new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}    aliens.append(new_alien)for alien in aliens[:3]:    if alien['color'] == 'green':        alien['color'] = 'yellow'        alien['speed'] = 'medium'        alien['points'] = 10## Show the first 5 aliens.for alien in aliens[:5]:    print(alien)print("...")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-7-2在字典中存储列表">4.7.2在字典中存储列表</h4><pre class="line-numbers language-language-python"><code class="language-language-python"> # Store information about a pizza being ordered.pizza = {    'crust': 'thick',    'toppings': ['mushrooms', 'extra cheese'],    }## Summarize the order.print(f"You ordered a {pizza['crust']}-crust pizza "    "with the following toppings:")for topping in pizza['toppings']:    print("\t" + topping)------You ordered a thick-crust pizza with the following toppings:        mushrooms           extra cheese<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-7-3在字典中存储字典">4.7.3在字典中存储字典</h4><pre class="line-numbers language-language-python"><code class="language-language-python">users = {    'aeinstein': {        'first': 'albert',        'last': 'einstein',        'location': 'princeton',        },    'mcurie': {        'first': 'marie',        'last': 'curie',        'location': 'paris',        },    }for username, user_info in users.items():    print(f"\nUsername: {username}")    full_name = f"{user_info['first']} {user_info['last']}"    location = user_info['location']    print(f"\tFull name: {full_name.title()}")    print(f"\tLocation: {location.title()}")------Username: aeinstein        Full name: Albert Einstein        Location: Princeton       Username: mcurie        Full name: Marie Curie            Location: Paris<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-用户输入与while循环">5.用户输入与while循环</h2><h3 id="5-1-函数input工作原理">5.1 函数input工作原理</h3><p>函数<code>input()</code>让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其赋给一个变量，以方便你使用。</p><pre class="line-numbers language-language-python"><code class="language-language-python">messgae = input("Tell me something, and I will repeat it back to you: ")print(message)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>函数<code>input()</code>接受一个参数，用于向用户显示提示或说明。</p><pre class="line-numbers language-language-python"><code class="language-language-python">prompt = "\nTell me something, and I will repeat it back to you!"prompt += "\nEnter 'quit' to end the program.\n>>>"active = Truewhile active:    message = input(prompt)    if message == 'quit':        active = False    else:        print(message)------Tell me something, and I will repeat it back to you!Enter 'quit' to end the program.>>>Hello!Hello!Tell me something, and I will repeat it back to you!Enter 'quit' to end the program.>>>quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-1-1使用int-来获取数值输入">5.1.1使用int()来获取数值输入</h4><pre class="line-numbers language-language-python"><code class="language-language-python">height = input("How tall are you, in inches? ")height = int(height)if height >= 48:    print("\nYou're tall enough to ride!")else:    print("\nYou'll be able to ride when you're a little older.")------How tall are you, in inches? 60You're tall enough to ride!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>int(height)</code>将height中所得到的字符变量转换成数值变量，类似于C语言强制转换。</p><h4 id="5-1-2求模运算符">5.1.2求模运算符</h4><p><code>%</code>将两个数相除并返回余数</p><pre class="line-numbers language-language-python"><code class="language-language-python">>>> 4 % 31>>> 5 % 32>>> 6 % 30 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2while循环">5.2while循环</h3><p>while循环中<code>break</code>结束语句和<code>continue</code>结束语句的区别</p><p><mark>while</mark></p><pre class="line-numbers language-language-python"><code class="language-language-python">prompt = "\nPlease enter the name of a city you have visited!"prompt += "\n(Enter 'quit' when you are finished.)\n"while True:    city = input(prompt)    if city == 'quit':        break    else:        print(f"I'd love to go to {city.title()}!")------Please enter the name of a city you have visited!(Enter 'quit' when you are finished.)WuhanI'd love to go to Wuhan!Please enter the name of a city you have visited!(Enter 'quit' when you are finished.)ShanghaiI'd love to go to Shanghai!Please enter the name of a city you have visited!(Enter 'quit' when you are finished.)quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark>continue</mark></p><pre class="line-numbers language-language-python"><code class="language-language-python">current_number = 0while current_number < 10:    current_number += 1    if current_number % 2 == 0:        continue    print(current_number)------13579<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><code>break</code>是终止整个while循环，<code>continue</code>是终止本次while循环</p></li></ul><h2 id="6-函数">6.函数</h2><h3 id="6-1传递实参">6.1传递实参</h3><h4 id="6-1-1位置实参">6.1.1位置实参</h4><p><strong>基于实参的顺序，将函数调用中的每个实参都关联到函数定义中的一个形参。</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">def describe_pet(animal_type, pet_name):    """Display information about a pet."""    print(f"\nI have a {animal_type}.")    print(f"My {animal_type}'s name is {pet_name.title()}.")describe_pet('cat', 'harry')describe_pet('dog', 'willie')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用位置实参来调用函数时，如果实参的顺序不正确，则会造成错误结果</strong></p><h4 id="6-1-2关键字实参">6.1.2关键字实参</h4><p><strong>使用关键字实参时，实参的顺序无关紧要，Python能够自动识别哪个实参的具体值该赋给哪个形参</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">def describe_pet(animal_type, pet_name):    """Display information about a pet."""    print(f"\nI have a {animal_type}.")    print(f"My {animal_type}'s name is {pet_name.title()}.")describe_pet(animal_type='cat', pet_name='harry')describe_pet(pet_name='willie', animal_type='dog')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-1-3指定默认值的形参">6.1.3指定默认值的形参</h4><pre class="line-numbers language-language-python"><code class="language-language-python">def describe_pet(pet_name, animal_type='dog'):    """Display information about a pet."""    print(f"\nI have a {animal_type}.")    print(f"My {animal_type}'s name is {pet_name.title()}.")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对上述带默认值的形参，以下几种函数调用都是等效的</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">#一只名为Willie的小狗describe_pet('willie')describe_pet(pet_name='willie')#一只名为harry的小猫describe_pet('harry', 'cat')describe_pet(pet_name='harry', animal_type='cat')describe_pet(animal_type='cat', pet_name='harry')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-1-4可选实参">6.1.4可选实参</h4><p>有的人无中间名，所有中间名这个参数是可选的，则将中间名放到函数形参的最后一个位置，以保证函数仅提供名和姓时该函数能够正确运行</p><pre class="line-numbers language-language-python"><code class="language-language-python">def get_formatted_name(first_name, last_name, middle_name=''):    """Return a full name, neatly formatted."""    if middle_name:        full_name = f"{first_name} {middle_name} {last_name}"    else:        full_name = f"{first_name} {last_name}"    return full_name.title()    musician = get_formatted_name('jimi', 'hendrix')print(musician)musician = get_formatted_name('john', 'hooker', 'lee')print(musician)------Jimi HendrixJohn Lee Hooker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-1-5传递任意数量的实参">6.1.5传递任意数量的实参</h4><h4 id="1-parameter元组形参法">1.<code>*parameter</code>元组形参法</h4><p>形参名<code>*parameter</code>中的星号让Python创建一个名为<code>parameter</code>的空元组，并将收到的所有值都封装到这个元组中。</p><pre class="line-numbers language-language-python"><code class="language-language-python">def make_pizza(size, *toppings):    """Summarize the pizza we are about to make."""    print(f"\nMaking a {size}-inch pizza with the following toppings:")    for topping in toppings:        print(f"- {topping}")make_pizza(16,'pepperoni')make_pizza(12,'mushrooms', 'green peppers', 'extea cheese')------Making a 16-inch pizza with the following toppings:- pepperoniMaking a 12-inch pizza with the following toppings:- mushrooms- green peppers- extea cheese<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-parameter字典形参法">2.<code>**parameter</code>字典形参法</h4><pre class="line-numbers language-language-python"><code class="language-language-python">def build_profile(first, last, **user_info):    """Build a dictionary containing everything we know about a user."""    user_info['first_name'] = first    user_info['last_name'] = last    return user_infouser_profile = build_profile('albert', 'einstein',                             location='princeton',                             field='physics')print(user_profile)------{'location': 'princeton', 'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2函数返回值">6.2函数返回值</h3><p>返回字典的情况</p><pre class="line-numbers language-language-python"><code class="language-language-python">def build_person(first_name, last_name, age=None):    """Return a dictionary of information about a person."""    person = {'first': first_name, 'last': last_name}    if age:        person['age'] = age    return personmusician = build_person('jimi', 'hendrix', age=27)print(musician)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3控制函数能否修改实参">6.3控制函数能否修改实参</h3><p>Python中，将一个实参传进函数，函数是会修改实参的值的。</p><p>若不想改变实参的值，则传进函数中的应该是实参的副本。</p><p>例如对于列表，则用列表切片法<code>[:]</code>建立副本，示例如下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">def change_list(list):    """    改变列表的值    """    while list:        del list[0]subjects = ['math', 'physics', 'chemistry']print(subjects)change_list(subjects)print(subjects)------['math', 'physics', 'chemistry'][]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">def change_list(list):    """    改变列表的值    """    while list:        del list[0]subjects = ['math', 'physics', 'chemistry']print(subjects)change_list(subjects[:])print(subjects)------['math', 'physics', 'chemistry']['math', 'physics', 'chemistry']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4导入函数或模块">6.4导入函数或模块</h3><h4 id="6-4-1导入整个模块">6.4.1导入整个模块</h4><ol><li class="lvl-3"><p>在<code>pizza.py</code>中编写函数<code>make_pizza()</code></p></li><li class="lvl-3"><p>在<code>main.py</code>中使用<u><strong><code>import pizza</code></strong></u>导入整个<code>pizza.py</code>模块</p></li><li class="lvl-3"><p>使用<code>pizza.py</code>模块中的函数`make_pizza()’</p></li><li class="lvl-3"><p>使用格式：<strong><u><code>pizza.make_pizza()</code></u></strong></p><p>即**<u><code>module_name.function_name()</code></u>**</p><p>注意：使用时文件名和函数名之间有句点！</p></li></ol><h4 id="6-4-2导入特定的函数">6.4.2导入特定的函数</h4><ul class="lvl-0"><li class="lvl-2"><p>语法：<strong><u><code>from module_name import function_name</code></u></strong></p></li><li class="lvl-2"><p>使用逗号分隔函数名，可根据需要从模块中导入任意数量的函数：</p><p><strong><u><code>from module_name import function0, function1, function2</code></u></strong></p></li><li class="lvl-2"><p>使用这种语法时，为显式导入，调用函数时无须使用句点</p></li></ul><h4 id="6-4-3使用as给函数指定别名">6.4.3使用<code>as</code>给函数指定别名</h4><ul class="lvl-0"><li class="lvl-2"><p>通用语法：<strong><u><code>from module_name import function_name as fn</code></u></strong></p></li><li class="lvl-2"><p>e.g.</p><pre class="line-numbers language-language-python"><code class="language-language-python">from pizza import make_piza as mpmp(16,'pepperoni')mp(12,'mushrooms', 'green peppers', 'extea cheese')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="6-4-4使用as给模块指定别名">6.4.4使用<code>as</code>给模块指定别名</h4><ul class="lvl-0"><li class="lvl-2"><p>通用语法：<strong><u><code>import module_name as mn</code></u></strong></p></li><li class="lvl-2"><p>e.g.</p><pre class="line-numbers language-language-python"><code class="language-language-python">import pizza as pp.make_pizza(16,'pepperoni')p.make_pizza(12,'mushrooms', 'green peppers', 'extea cheese')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="6-4-5导入模块中的所有函数">6.4.5导入模块中的所有函数</h4><ul class="lvl-0"><li class="lvl-2"><p>优点：相较于导入整个模块，此方法导入整个模块中的所有函数可以**<u>避免使用句点表示法</u>**</p></li><li class="lvl-2"><p>缺点：使用自己编写的大型模块时，若采用这种表示方法，可能会由于模块中有函数的名称与当前项目中已有的函数名称相同，导致函数的覆盖和错误使用。</p></li><li class="lvl-2"><p>通用语法：<strong><u><code>from module_name import *</code></u></strong></p></li></ul><h2 id="7-类">7.类</h2><blockquote><p>PS：由于自己一个个字敲太花时间了，类的这部分笔记是直接copy后修改了一些，找的这一篇也都是照着蛇书一个个字敲的，所以也刚好“适配”和“兼容”，特别感谢作者！以下附链接：</p><p><a href="https://blog.csdn.net/QINGDI1122/article/details/108048515">python – 类（学习笔记）_stayfsh的博客-CSDN博客</a></p></blockquote><p>面向对象编程是最有效的软件编写方法之一。在面向对象编程中，我们编写表示现实世界中事务和情景的类，并基于这些类创建。根据类来创建对象被称为实例化，这让我们能使用类的实例。</p><h3 id="7-1-创建和使用类">7.1 创建和使用类</h3><h4 id="7-1-1-创建Dog类">7.1.1 创建Dog类</h4><p>根据Dog类创建的每个实例都将存储名字和年龄。我们赋予了每条小狗蹲下（sit（））和打滚（roll_over（））的能力。</p><pre class="line-numbers language-language-python"><code class="language-language-python">class Dog:    """一次模拟小狗的简单尝试。"""        def __init__(self,name,age):        """初始化属性name和age。"""        self.name = name        self.age = age            def sit(self):        """模拟小狗被命令时蹲下"""        print(self.name.title() +"is now sitting.")            def roll_over(self):        """模拟小狗被命令时打滚"""        print(self.name.title()+"rolled over!")        /print(f"{self.name} rolled over!")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据约定，在Python中，<strong>首字母大写</strong>的名称指的是<strong>类</strong>，这个类定义中没有圆括号，因为我们要从空白创建这个类。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>方法<code>_init_()</code>:</strong></p></li><li class="lvl-2"><p>类中的函数称为方法；<code>_ init_()</code>方法是一个特殊方法，每当我们根据Dog类创建实例时，python都会自动运行它。</p></li><li class="lvl-2"><p>在上面例子中我们将方法_init_（）定义成包含三个形参：<code>self</code>，<code>name</code>，<code>age</code>。在这个方法的定义中，形参<code>self</code>必不可少，而且要位于其他形参之前，这是因为python调用这个<code>_init_()</code>方法创建实例时，将自动传入实参self。每个与类相关联的方法调用都自动传递实参<code>self</code>，它是一个指向实例本身的引用，让实例能访问类中属性和方法。</p></li><li class="lvl-2"><p>我们创建Dog实例时，python将调用Dog类的方法<code>_init_()</code>。我们将通过实参向<code>Dog()</code>传递名字和年龄；<code>self</code>会自动传递，因此我们不需要传递它。</p></li><li class="lvl-2"><p>Dog类还定义了另外两个方法：<code>sit()</code>和<code>roll_over()</code>。由于这些方法不需要额外的信息，如名字和年龄，因此它们只有一个形参self。</p></li></ul><h4 id="7-1-2-根据类创建实例">7.1.2 根据类创建实例</h4><p>可将类视为有关如何创建实例的说明。Dog类是一系列说明，让Python知道如何创建表示特定小狗的实例。下面来创建一个表示特定小狗的实例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">class Dog:    def __init__(self,name,age):        self.name = name        self.age = age    def sit(self):        """模拟小狗被命令时蹲下"""        print(self.name.title() +"is now sitting.")    def roll_over(self):        """模拟小狗被命令时打滚"""        print(self.name.title()+"rolled over!")my_dog=Dog('willie',6)print("My dog's name is"+my_dog.name.title()+".")print("My dog is"+str(my_dog.age)+"year old.")####My dog's name isWillie.My dog is 6 year old.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用的是之前编写的Dog类，我们创建一条名字为 ‘wille’ ，年龄为6的小狗。遇到这行代码时，python使用实参 ‘wille’ 和 6调用Dog类中的方法 <code>_ init_()</code>。方法_ <code>_init_()</code>创建一个表示特定小狗的实例，并使用我们提供的值来设置属性name和age。方法<code>_ init_()</code>并未显示的包含return语句，但python自动返回一个表示这条小狗的的实例。我们将这个实例存储在变量my_dog中。</p><p><strong>调用方法</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">my_dog.sit()my_dog.roll_over()###Willieis now sitting.Willierolled over!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建多个实例</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">my_dog = Dog('willie',6)your_dog = Dog('lucy',3)print("My dog's name is"+my_dog.name.title()+".")print("My dog is "+str(my_dog.age)+" year old.")my_dog.sit()my_dog.roll_over()print("\nYour dog's name is "+your_dog.name.title()+".")print("Your dog is "+str(your_dog.age)+"years old.")your_dog.sit()your_dog.roll_over()####My dog's name isWillie.My dog is 6 year old.Willie is now sitting.Willie rolled over!Your dog's name is Lucy.Your dog is 3 years old.Lucyis now sitting.Lucyrolled over!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里我们创建了两条小狗，分别命名为willie和lucy。每条小狗都是一个独立的实例，有自己的一组属性。</p><h3 id="7-2使用类和实例">7.2使用类和实例</h3><p>我们可以用类来模拟现实世界中的很多情景。类编写好后，我们的大部分时间都将花费在类创建的实例上。我们需要执行的一个重要任务是修改实例的属性。我们可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。</p><h4 id="7-2-1-Car-类">7.2.1 Car 类</h4><p>下面来编写一个汽车类，它存储了有关汽车的信息，还有一个汇总这些信息的方法：</p><pre class="line-numbers language-language-python"><code class="language-language-python">class Car:"""一次模拟汽车的简单尝试"""    def __init__(self,make,model,year):    """初始化汽车属性"""        self.make = make        self.model = model        self.year = year            def get_descriptive_name(self):        """返回整洁的描述性信息"""        long_name = str(self.year)+' '+self.make+' '+self.model        return long_name.title()my_new_car=Car('audi','a4',2023)print(my_new_car.get_descriptive_name())###2023 Audi A4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-2-2-给属性指定默认值">7.2.2 给属性指定默认值</h4><p>类中的每个属性都必须有初始值，哪怕这个值是零或者空字符。在有些情况下，如果设置默认值时，在方法<code>_init_()</code>内指定这种初始值是可行的。如果我们对某个属性这样做了，就无须包含为它提供初始值的形参。</p><pre class="line-numbers language-language-python"><code class="language-language-python">class Car:    def __init__(self,make,model,year):        self.make = make        self.model = model        self.year = year        self.odometer_reading = 0            def get_descriptive_name(self):        long_name=str(self.year) + ' ' + self.make + ' ' + self.model        return long_name.title()        def read_odometer(self):        """打印汽车里程信息"""        print("This car has " + str(self.odometer_reading) + " miles on it.")        my_new_car = Car('audi','a4',2023)print(my_new_car.get_descriptive_name())my_new_car.read_odometer()####2023 Audi A4This car has 0 miles on it.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面程序中添加了一个名为<code>odometer_reading</code>的属性，其初始值总是为0.我们还添加了一个名为<code>read_odometer()</code>方法，用于读取汽车的里程表。</p><h4 id="7-2-3-修改属性的值">7.2.3 修改属性的值</h4><p>可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行设置；通过方法进行递增（增加特定的值）。</p><ol><li class="lvl-3"><p><strong>直接修改属性的值</strong></p></li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">my_new_car.odometer_reading = 23my_new_car.read_odometer()####This car has 23 miles on it.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li class="lvl-3"><p><strong>通过方法修改属性的值</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">class Car:--snip--       def update_odometer(self,mileage):    """    通过方法修改属性的值    且禁止将里程数往回调    """if mileage >= self.odometer_reading:self.odometer_reading = mileage        else:        print("You can't roll back an odometer!")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们新增的<code>update_odometer()</code>会在修改属性前检查指定的读书是否合理。</p></li><li class="lvl-3"><p><strong>通过方法对属性的值进行递增</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">class Car:--snip--    def update_odometer(self,mileage):--snip--        def increment_odometer(self,miles):        """将里程表数增加一个指定的量"""self.odometer_reading += milesmy_new_car=Car('subaru','outback',2013)print(my_new_car.get_descriptive_name())my_new_car.update_odometer(23500)my_new_car.read_odometer()my_new_car.increment_odometer(100)my_new_car.read_odometer()####2013 Subaru OutbackThis car has 23500 miles on it.This car has 23600 miles on it.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新增的方法increment_odometer（）接受一个单位为英里的数字，并将其加入到self.odometer_reading中。</p></li></ol><h3 id="7-3继承">7.3继承</h3><p>编写类时，并非总是要从空白开始。如果我们要编写的类时另一个现成类的特殊版本，可以考虑使用<strong>继承</strong>。一个类继承另一个类时，<strong>它将自动获得另一个类的所有属性和方法</strong>；原有的类称为<strong>父类</strong>，而新的类称为<strong>子类</strong>。子类继承其父类的所有属性和方法，<strong>同时还可以定义自己属性和方法</strong>。</p><h4 id="7-3-1子类的方法-init">7.3.1子类的方法<code>_init_()</code></h4><p>下面，我们在前面创建的<code>Car</code>类的基础上创建新类<code>ElectricCar</code>，这样我们只需要为电动汽车特有的属性和行为编写代码。</p><p><mark>创建子类时，父类必须包含在当前文件夹中，且位于子类前面。</mark><mark>定义子类时，必须在圆括号内指定父亲的名称</mark>例如，下面定义子类时，<code>ElectricCar</code>后又括号且括号中有内容<code>Car</code>，即定义时，代码为<code>class ElectricCar(Car)</code>。</p><pre class="line-numbers language-language-python"><code class="language-language-python">class Car:   --snip--class ElectricCar(Car):    """电动汽车子类"""    def __init__(self,make,model,year):        """初始化父类的属性"""        super().__init__(make,model,year)my_tesla = ElectricCar('tesla','model s',2016)print(my_tesla.get_descriptive_name())####2016 Tesla Model S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark><code>super()</code><mark>是一个特殊函数，帮助python将父类和子类关联起来。这行代码让python调用<code>Car</code>父类的方法<code>_init_()</code>,让ElectricCar实例包含这个方法中定义的所有属性。父类也称为</mark>超类</mark>，名称<code>super</code>也由此而来。</p><h4 id="7-3-2-给子类定义属性和方法">7.3.2 给子类定义属性和方法</h4><p>下面我们来添加一个电动车特有属性（电瓶），以及一个描述该属性的方法。我们将存储电瓶容量，并且编写一个打印电瓶描述的方法：</p><pre class="line-numbers language-language-python"><code class="language-language-python">class Car:   --snip--class ElectricCar(Car):        def __init__(self,make,model,year):        super().__init__(make,model,year)        self.battery_size = 70            def describe_battery(self):        print("This car has a " + str(self.battery_size) + "-kWh battery.")my_tesla = ElectricCar('tesla','model s',2016)print(my_tesla.get_descriptive_name())my_tesla.describe_battery()  ####2016 Tesla Model S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-3-3-重写父类的方法">7.3.3 重写父类的方法</h4><p>对于父类的方法，只要它有不符合子类模拟的实物的行为，都可以对其进行重写。为此，可以在子类中定义一个这样的方法，即它要与重写的父类方法同名。这样，python将只会关注我们在子类中定义的相应方法。</p><p>假设<code>Car</code>类有一个名为<code>fill_gas_tank()</code>的方法，它对全电动汽车来说毫无意义，因此你可能想重写它。下面演示了一种重写方式。</p><pre class="line-numbers language-language-python"><code class="language-language-python">class ElectricCar(Car)：--snip--def fill_gas_tank(self):        """电动汽车没有油箱。"""        print("This car doenn't need a gas tank!")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.1.3 重写父类的方法对于父类的方法，只要它有不符合子类模拟的实物的行为，都可以对其进行重写。为此，可以在子类中定义一个这样的方法，即它要与重写的父类方法同名。这样，python将只会关注我们在子类中定义的相应方法。</p><h4 id="7-3-4-将实例用作属性">7.3.4 将实例用作属性</h4><p>使用代码模拟实物时，我们可能会发现给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。我们可以将大类拆分成多个协同工作的小类。例如，不断给<code>ElectricCar</code>类添加细节时，我们可能会发现其中包含很多专门针对汽车电脑电瓶的属性和方法。在这种情况下，我们可将这些属性和方法提取出来，放到另一个名为<code>Battery</code>的类中，并将一个<code>Battery</code>实例用作<code>ElectricCar</code>类的一个属性：</p><pre class="line-numbers language-language-python"><code class="language-language-python">class Car:   --snip--class Battery:    """一次模拟电动车电瓶的简单尝试"""        def __init__(self,battery_size=70):        """初始化电瓶的属性"""        self.battery_size=battery_size            def describe_battery(self):        """打印一条描述电瓶的容量"""        print("This car has a "+str(self.battery_size)+"-kWh battery.")class ElectricCar(Car):    """电动汽车的独特之处"""        def __init__(self,make,model,year):        """        初始化父类的属性        在初始化电动汽车特有的属性        """        super().__init__(make,model,year)        self.battery = Battery()my_tesla = ElectricCar('tesla','model s',2016)print(my_tesla.get_descriptive_name())my_tesla.battery.describe_battery()####2016 Tesla Model S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码看似做了很多额外的工作，但好处是现在我们多详细描述电瓶都可以，切不会导致<code>ElectricCar</code>类混乱不堪。</p><h3 id="7-4导入类">7.4导入类</h3><p>python允许我们将类存储在模块中，然后在主程序中导入所需的模块。</p><h4 id="7-4-1-导入单个类">7.4.1 导入单个类</h4><p>我们可以创建一个只包含<code>Car</code>类的模块，我们可以将这个模块命名为<code>car.py</code>。然后我们可以新创建其他文件，并在其中导入我们创建好的<code>Car</code>模块。例如，我们创建新文件<code>new_car</code>：</p><pre class="line-numbers language-language-python"><code class="language-language-python">from car import Carmy_new_car=Car('auid','a4',2016)print(my_new_car.get_descriptive_name())my_new_car.odometer_reading =23my_new_car.read_odometer()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一句处的<code>import</code>语句让python打开模块<code>car</code>，并导入其中的<code>Car</code>类，这样我们就可以使用<code>Car</code>类了。</p><h4 id="7-4-2-在一个模块中存储多个类">7.4.2 在一个模块中存储多个类</h4><h4 id="7-4-3-从一个模块中导入多个类">7.4.3 从一个模块中导入多个类</h4><pre class="line-numbers language-language-python"><code class="language-language-python">from car import Car，ElectriCar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-4-4-导入整个模块">7.4.4 导入整个模块</h4><pre class="line-numbers language-language-python"><code class="language-language-python">import car<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-4-5-导入模块中所有类">7.4.5 导入模块中所有类</h4><pre class="line-numbers language-language-python"><code class="language-language-python">from module_name import *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不推荐这种方法，原因如下：</p><ol><li class="lvl-3"><p>如果只看开头的<code>import</code>语句，就能清楚地知道程序使用了哪些类，将大有裨益。然而这种导入方式没有明确地指出使用了模块中的哪些类。</p></li><li class="lvl-3"><p>如果不小心导入了一个与程序文件中其他东西<strong>同名</strong>的类，将引发难以诊断的错误。</p></li></ol><h4 id="7-4-6使用别名">7.4.6使用别名</h4><pre class="line-numbers language-language-python"><code class="language-language-python">from electric_car import ElectricCar as ECmy_tesla = EC('tesla', 'roadster'. 2023)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="7-5类编码风格">7.5类编码风格</h3><ol><li class="lvl-3"><p>类名应该采用<mark>驼峰命名法</mark>，即将类名中的<strong>每个单词的首字母都大写</strong>，而不使用<strong>下划线</strong></p></li><li class="lvl-3"><p>实例名和模块名都采用小写格式，并在单词之间加上下划线。</p></li><li class="lvl-3"><p>对于每个模块/类/方法，都应该在定义后面包含一个文档字符串</p></li><li class="lvl-3"><p>方法之间用一个空行来分隔，模块之间用两个空行来分隔</p></li></ol><h2 id="8-文件和异常">8.文件和异常</h2><blockquote><p>PS：同样，文件和异常的笔记也是在别的作者的基础上修改而得（原作者很多细节都直接忽略了，也由于蛇书的版本不同，补充修改了很多）</p><p>8.1文件部分参考出处：<a href="https://blog.csdn.net/QINGDI1122/article/details/107971793">python - 文件操作（学习笔记）_stayfsh的博客-CSDN博客</a></p><p>8.2异常部分参考出处：<a href="https://blog.csdn.net/Lance_Lewu/article/details/104417936"> Python学习笔记-异常及处理_Lance_Lewu的博客-CSDN博客</a></p></blockquote><h3 id="8-1-从文件中读取数据">8.1 从文件中读取数据</h3><p>文本文件可以存储的数据量非常多：天气数据，交通数据，社会经济数据，文学作品等等。每当需要分析和修改文件中的数据时，读取文件都是非常重要的，对数据分析更是如此。</p><h4 id="8-1-1读取整个文件">8.1.1读取整个文件</h4><p><code>pi_digits.txt</code>文件中存储的是小数点后30位的圆周率值，且在小数点后每10位处换行。</p><pre class="line-numbers language-language-python"><code class="language-language-python">with open('pi_digits.txt') as file_object:    contents = file_object.read()    print(contents)####3.1415926535  8979323846  2643383279<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><strong><code>关键字with</code></strong>：在不需要访问文件后将其关闭。在此程序中，我们调用了<code>open()</code>，但没有调用<code>close()</code>，即打开了但没有关闭文件，但由于执行程序时<code>close()</code>的位置往往不好确定，易产生<strong>bug</strong>导致文件未正常关闭，可能造成数据丢失或受损。且过早关闭往往会导致需要使用此文件时该文件已关闭。通过**<code>关键字with</code><strong>，<code>Python</code>可以自己去确定关闭文件的时机（即</strong><code>with</code>**后缩进相同的部分）。</p></li><li class="lvl-2"><p><strong><code>函数open()</code></strong>：</p><pre class="line-numbers language-language-python"><code class="language-language-python">open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用参数说明（其他参数略）：</p><blockquote><ul class="lvl-3"><li class="lvl-2"><p><code>file</code>：<code>Python</code>在当前执行文件所在的目录查找指定文件。</p></li></ul></blockquote></li></ul><blockquote><ul class="lvl-1"><li class="lvl-2"><p>mode ：打开文件的模式，默认为<code>r</code>（只读模式）。常用的模式包括：</p><ul class="lvl-3"><li class="lvl-4"><code>'r'</code>：只读模式。</li><li class="lvl-4"><code>'w'</code>：写入模式，<strong>如果文件已存在则覆盖原有内容</strong>，若文件不存在则创建新文件。</li><li class="lvl-4"><code>'a'</code>：追加模式/附加模式，<strong>将文本写入到文件末尾</strong>，若文件不存在则创建新文件。</li><li class="lvl-4"><code>'x'</code>：独占创建模式，只在文件不存在时创建文件，若文件已存在则抛出异常。</li><li class="lvl-4"><code>'b'</code>：二进制模式。</li><li class="lvl-4"><code>'t'</code>：文本模式（默认模式）。</li><li class="lvl-4"><code>'+'</code>/<code>r+</code>：更新模式，允许读写操作。</li></ul></li><li class="lvl-2"><p><code>encoding</code>：用于指定文件的编码方式。例如，<code>'utf-8'</code>。</p></li></ul></blockquote><ul class="lvl-0"><li class="lvl-2"><p><code>方法read()</code>：读取文件。<code>read()</code>到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在函数调用<code>print()</code>中使用<code>strip()</code></p></li></ul><h4 id="8-1-2文件路径">8.1.2文件路径</h4><p><code>Python</code>默认在当前执行文件所在的目录查找指定文件，<strong>不会去搜寻子文件夹</strong>，更不能是上层文件夹。相对路径：</p><pre class="line-numbers language-language-python"><code class="language-language-python">with open('text_files/filename.txt') as file_object:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>绝对路径：</p><pre class="line-numbers language-language-python"><code class="language-language-python">with open('C:/User/enmatthe/text_files/filename.txt') as file_object:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>注意：</strong></p><ol><li class="lvl-3">显示文件路径时,<code>Windows</code>系统使用反斜杠（<code>\</code>）而不是斜杠（<code>/</code>）</li><li class="lvl-3">如果在文件路径中直接使用反斜杠，将引发错误，因为反斜杠用于对字符串中的字符进行转义。e.g.路径<code>C:\Path\to\file.txt</code>中的<code>\t</code>将被解读为制表符。如果一定要使用反斜杠，可对路径中的每个反斜杠都进行转义，如<code>C:\\path\\to\\file.txt</code></li></ol></blockquote><h4 id="8-1-3逐行读取文件">8.1.3逐行读取文件</h4><pre class="line-numbers language-language-python"><code class="language-language-python">with open('pi_digits.txt') as file_object:    for line in file_object:        print(line) #### 3.1415926535  8979323846  2643383279<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们发现逐行读取这样操作由于<strong>每行末尾的换行符</strong>作用使得<strong>各行之间空白增多</strong>。所以我们可以使用<code>rstrip()</code>方法来进行处理</p><pre class="line-numbers language-language-python"><code class="language-language-python">print(line.rstrip())<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-1-4使用文件的内容">8.1.4使用文件的内容</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>创建一个包含文件各行内容的列表</strong></p></li></ul><pre class="line-numbers language-language-python"><code class="language-language-python">with open('pi_digits.txt') as file_object:    lines=file_object.readlines()    for line in lines:    print(line.rstrip())####3.1415926535  8979323846  2643383279<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>with</code>时，<code>open()</code>返回的文件对象只能在<code>with</code>代码块内使用，如果想在<code>with</code>代码块外访问文件内容，可以在<code>with</code>代码块内将文件的各行存储在一个列表中，并在<code>with</code>代码块外使用列表就可以了。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>使用文件</strong></p></li></ul><p>下面是一个简单的使用示例：</p><pre class="line-numbers language-language-python"><code class="language-language-python">with open('pi_digits.txt') as file_object:    lines=file_object.readlines()    pi_string=''for line in lines:    pi_string+=line.rstrip()print(pi_string)print(len(pi_string))3.1415926535  8979323846  264338327936<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用<code>strip()</code>方法来代替<code>rstrip()</code>可以输出如下结果：</p><pre class="line-numbers language-language-python"><code class="language-language-python">for line in lines:    pi_string+=line.strip()####3.14159265358979323846264338327932<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2异常">8.2异常</h3><p><code>Python</code>使用称为<strong>异常</strong>的特殊对象来管理程序执行期间发生的错误。使用<code>try-except</code>代码块处理。出现异常时，显示代码作者编写的友好的错误消息，而不是**<code>traceback</code><strong>，由于</strong><code>traceback</code>**报错时会显示部分程序代码，训练有素的攻击者往往会根据显示的部分代码而对程序发动定向攻击，造成程序的崩溃。</p><h4 id="8-2-1try-except代码块">8.2.1<code>try-except</code>代码块</h4><pre class="line-numbers language-language-python"><code class="language-language-python">try:    可能出现错误的语句段except [指定的异常类型]:  # 指定一种异常类型    出现该类异常以后的处理except Exception as e:  # 放在最后，兜底接收其他错误类型    print(e) # 输出错误信息    默认的错误处理else:    try下代码块执行结束，没有遇到异常后，执行的代码块finally:    无论有没有异常都会执行的代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>Exception</code></strong> 是<strong>所有异常的父类</strong>，通常放在最后用来接收未知的错误类型.</p><p>**<code>except</code>**后常见异常类型：</p><ol><li class="lvl-3"><p><code>NameError</code>：名称错误，通常是由于访问了未定义的变量或函数导致的。</p></li><li class="lvl-3"><p><code>TypeError</code>：类型错误，通常是由于操作数的类型不匹配导致的。</p></li><li class="lvl-3"><p><code>ValueError</code>：值错误，通常是由于操作数的值不合法导致的。</p></li><li class="lvl-3"><p><code>KeyError</code>：键错误，通常是由于访问字典时使用了不存在的键导致的。</p></li><li class="lvl-3"><p><code>FileNotFoundError</code>：文件未找到错误，通常是由于尝试打开不存在的文件导致的。</p></li><li class="lvl-3"><p><code>ImportError</code>：导入错误，通常是由于无法导入模块或包导致的。</p></li><li class="lvl-3"><p><code>ZeroDivisionError</code>：除零错误，通常是由于进行了除零操作导致的。</p></li></ol><h4 id="8-2-2异常中return执行顺序">8.2.2异常中return执行顺序</h4><ul class="lvl-0"><li class="lvl-2"><p>无finally</p><ol><li class="lvl-5"><strong>try中有return</strong>： 立刻返回，结束程序段的执行</li><li class="lvl-5"><strong>else中有return</strong>： 立刻返回，结束程序段的执行</li></ol></li><li class="lvl-2"><p>有finally</p><ol><li class="lvl-5"><strong>try中有return而finally中无</strong>： 暂缓return，待finally执行完毕后返回</li><li class="lvl-5"><strong>else中有return而finally中无</strong>： 暂缓return，待finally执行完毕后返回</li><li class="lvl-5"><strong>finally中有return</strong>：无论try或else中是否有return，均以finally中返回的为准</li></ol></li></ul><p><strong>异常传递</strong><br>如果调用关系有多层，那么内层如果出错，错误就会被层层抛出，直到在某处被捕获或处理。如果直到最终调用处都未被捕获或处理，那么就会被抛出</p><p><strong>自定义异常</strong><br>当系统给定的异常不能满足需求时，可以使用自定义异常来进行补充</p><h4 id="8-2-3自定义一个异常">8.2.3自定义一个异常</h4><pre class="line-numbers language-language-python"><code class="language-language-python">class UserNameError(Exception):   def __init__(self,*args,**kwargs):       pass#在方法中使用自定义异常def setUserName():   username = input('请输入用户名：')   if len(username)<6 or username[0].isdigit():       raise UserNameError('用户名格式错误')   # 用raise抛出异常   else:       print('输入成功')try:   setUserName()except Exception as e:  # 接收异常   print(e)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-3使用json-dump-和json-load-存储数据">8.3使用<code>json.dump()</code>和<code>json.load()</code>存储数据</h3><p>很多程序要求用户输入某种信息，例如让用户存储游戏首选项或提供要可视化的数据。不管专注的是什么，程序都把用户提供的信息存储在列表和字典等数据结构中。要保存这些信息，一种简单的方法是使用<code>json()</code>模块来存储数据。模块<code>json</code>能让我们将简单的的<code>python</code>数据结构转存储到文件中，并在文件运行时加载该文件中的数据。我们还可以使用<code>json</code>在<code>python</code>程序之间分享数据。</p><blockquote><p><strong><code>json</code></strong>(<code>JSON, JavaScript Obkect Notation</code>)格式最初是为<code>JavaScript</code>开发的，但随后成立一种常见格式，被包括<code>Python</code>在内的众多语言采用。</p></blockquote><p>存储一组数字的例子：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import jsonnumbers = [2,3,5,7,11,13]filename = 'numbers.json'with open(filename,'w') as f:    json.dump(numbers,f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>json.dump()</code>是将数字列表存储到文件<code>numbers.json</code>中，这个程序没有输出。<code>json.dump()</code>接受两个实参：要存储的数据，以及可用于存储数据的文件对象。</p><p>下面再写一个程序，使用<code>json.load()</code>将这个列表读取到内存中：</p><pre class="line-numbers language-language-ython"><code class="language-language-ython">import jsonfilename = 'numbers.json'with open(filename) as f:    numbers = json.load(f)print(numbers)####[2, 3, 5, 7, 11, 13]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-单元测试">9.单元测试</h2><p>单元测试是一种软件测试方法，用于测试程序的最小可测试单元（通常是函数或方法）是否按照预期进行工作。它的目的是确保单元在隔离的环境中能够正确、可靠地完成其指定的功能。</p><h3 id="9-1unittest单元测试格式">9.1<code>unittest</code>单元测试格式</h3><h4 id="9-1-1单元测试框架：">9.1.1单元测试框架：</h4><ul class="lvl-0"><li class="lvl-2"><p><code>unittest</code>：Python 标准库中的测试框架，使用类和方法来创建测试用例和测试套件。</p></li><li class="lvl-2"><p><code>pytest</code>：一个功能强大且易于使用的第三方测试框架，具有简洁的语法和丰富的插件生态系统。</p></li><li class="lvl-2"><p><code>doctest</code>：可以直接从函数的文档字符串中提取测试用例，并执行函数并验证输出结果是否符合预期。</p></li><li class="lvl-2"><p>其他第三方测试框架：如 <code>nose</code>、<code>nose2</code>、<code>tox</code> 等。</p></li></ul><h4 id="9-1-2格式：">9.1.2格式：</h4><p>在使用 <code>unittest</code> 进行单元测试时，有一些常用的格式和约定可以遵循，以提高测试代码的可读性和维护性。以下是一些常见的 <code>unittest</code> 测试单元的格式：</p><ol><li class="lvl-3"><p>测试类的命名：测试类的命名通常以 “Test” 开头，后面跟着要测试的类的名称。例如，要测试名为 <code>Calculator</code> 的类，测试类的命名可以是 <code>TestCalculator</code>。</p></li><li class="lvl-3"><p>测试方法的命名：测试方法的命名通常以 “test_” 开头，后面跟着函数或方法的功能描述。例如，测试一个加法函数的功能，测试方法的命名可以是 <code>test_addition()</code>。</p></li><li class="lvl-3"><p>导入和继承：在编写测试代码时，通常需要导入 <code>unittest</code> 模块，并创建一个继承自 <code>unittest.TestCase</code> 的测试类。</p></li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">import unittestclass TestCalculator(unittest.TestCase):    # 测试方法定义在这里    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li class="lvl-3"><p>断言语句：使用断言语句来验证测试的期望结果与实际结果是否一致。<code>unittest</code> 提供了许多用于断言的方法，如 <code>assertEqual()</code>、<code>assertTrue()</code>、<code>assertFalse()</code> 等。</p></li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">def test_addition(self):    result = addition(2, 3)    self.assertEqual(result, 5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="5"><li class="lvl-3"><p>使用 <code>setUp()</code> 和 <code>tearDown()</code>：在需要共享设置或资源的测试之间使用 <code>setUp()</code> 和 <code>tearDown()</code> 方法。<code>setUp()</code> 方法在每个测试方法之前执行一次，用于准备测试所需的环境。<code>tearDown()</code> 方法在每个测试方法之后执行一次，用于清理测试过程中创建的任何资源。</p></li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">def setUp(self):    # 设置测试环境def tearDown(self):    # 清理测试环境<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li class="lvl-3"><p>运行测试：使用 <code>unittest.main()</code> 运行测试，它会执行测试类中的所有测试方法。</p></li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">if __name__ == '__main__':    unittest.main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="7"><li class="lvl-3"><p>使用 <code>TestSuite</code>：如果需要自定义测试执行顺序，可以创建一个 <code>TestSuite</code> 对象，并将测试方法添加到该对象中。</p></li></ol><pre class="line-numbers language-language-python"><code class="language-language-python">suite = unittest.TestSuite()suite.addTest(TestCalculator("test_addition"))suite.addTest(TestCalculator("test_subtraction"))...unittest.TextTestRunner().run(suite)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-1-3示例：">9.1.3示例：</h4><pre class="line-numbers language-language-python"><code class="language-language-python">import unittest # 必须步骤def add(a, b):    return a + bclass TestAdd(unittest.TestCase): # 必须步骤    def test_1_plus_1(self):        result = add(1, 1)        self.assertEqual(result, 2) # 断言方法assert，核实得到的结果是否与期望的结果一致    def test_negative_numbers(self):        result = add(-5, -10)        self.assertEqual(result, -15)    def test_mixed_numbers(self):        result = add(3, -7)        self.assertEqual(result, -4)if __name__ == '__main__': # 必须步骤    unittest.main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述示例中，我们使用 <code>unittest</code> 框架编写了一个简单的测试用例。测试用例是通过创建一个继承自 <code>unittest.TestCase</code> 的类，并在其中定义以 <code>test_</code> 开头的测试方法来实现的。每个测试方法都使用断言语句来验证函数的返回值是否与预期结果一致。最后，在 <code>__main__</code> 中调用 <code>unittest.main()</code> 来执行测试。</p><p>当执行这段代码时，测试框架将会执行所有的测试方法并输出测试结果。如果所有的断言都为真，则测试通过；如果有任何一个断言失败，则测试失败，并输出详细的错误信息。</p><h3 id="9-2setUp-方法">9.2<code>setUp()</code>方法</h3><p>在单元测试中，<code>setUp()</code> 方法是 <code>unittest.TestCase</code> 类中的一个特殊方法，在每个测试方法执行之前被调用。<code>setUp()</code> 方法可以用来设置测试环境，进行一些初始化操作，以确保每个测试方法都在相同的环境中运行。</p><p><code>setUp()</code> 方法的主要作用是为每个测试方法创建一个干净的测试环境，并在该环境中进行实际的测试操作。在该方法中可以进行一些常见的设置工作，例如创建测试数据、连接数据库、打开文件或初始化对象等。</p><p>下面是一个示例，展示了如何在单元测试中使用 <code>setUp()</code> 方法：</p><pre class="line-numbers language-language-python"><code class="language-language-python">import unittestclass ExampleTestCase(unittest.TestCase):    def setUp(self):        # 设置测试环境        self.data = [1, 2, 3, 4, 5]    def test_sum(self):        # 在测试方法中使用设置的数据进行测试        result = sum(self.data)        self.assertEqual(result, 15)    def test_length(self):        # 在测试方法中使用设置的数据进行测试        length = len(self.data)        self.assertEqual(length, 5)if __name__ == '__main__':    unittest.main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的示例中，我们创建了一个名为 <code>ExampleTestCase</code> 的测试类。在 <code>setUp()</code> 方法中，我们初始化了一个名为 <code>data</code> 的列表，该列表将在每个测试方法中被使用。</p><p>然后，在两个测试方法 <code>test_sum()</code> 和 <code>test_length()</code> 中，我们使用了 <code>data</code> 列表进行实际的测试。我们分别计算了列表元素的和并进行断言，以及计算列表的长度并进行断言。</p><p>每次执行测试时，<code>setUp()</code> 方法都会在每个测试方法之前执行一次，确保每个测试方法都在同样的环境下进行操作，以提供可靠的测试结果。</p><p>需要注意的是，<code>setUp()</code> 方法只会在每个测试方法开始之前执行一次，即使测试类中有多个测试方法，也只会执行一次。如果你希望在每个测试方法之后执行一些清理操作，可以使用 <code>tearDown()</code> 方法来完成。</p><h2 id="10-正则表达式">10.正则表达式</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tutorial</title>
      <link href="/20230728/tutorial/"/>
      <url>/20230728/tutorial/</url>
      
        <content type="html"><![CDATA[<h2 id="Front-matter-选项详解">Front-matter 选项详解</h2><table><thead><tr><th style="text-align:left">配置选项</th><th style="text-align:left">默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">title</td><td style="text-align:left"><code>Markdown</code> 的文件标题</td><td style="text-align:left">文章标题，强烈建议填写此选项</td></tr><tr><td style="text-align:left">date</td><td style="text-align:left">文件创建时的日期时间</td><td style="text-align:left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td style="text-align:left">author</td><td style="text-align:left">根 <code>_config.yml</code> 中的 <code>author</code></td><td style="text-align:left">文章作者</td></tr><tr><td style="text-align:left">img</td><td style="text-align:left"><code>featureImages</code> 中的某个值</td><td style="text-align:left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td style="text-align:left">top</td><td style="text-align:left"><code>true</code></td><td style="text-align:left">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td style="text-align:left">cover</td><td style="text-align:left"><code>false</code></td><td style="text-align:left"><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td style="text-align:left">coverImg</td><td style="text-align:left">无</td><td style="text-align:left"><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td style="text-align:left">password</td><td style="text-align:left">无</td><td style="text-align:left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td style="text-align:left">toc</td><td style="text-align:left"><code>true</code></td><td style="text-align:left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td style="text-align:left">mathjax</td><td style="text-align:left"><code>false</code></td><td style="text-align:left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td style="text-align:left">summary</td><td style="text-align:left">无</td><td style="text-align:left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td style="text-align:left">categories</td><td style="text-align:left">无</td><td style="text-align:left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td style="text-align:left">tags</td><td style="text-align:left">无</td><td style="text-align:left">文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li class="lvl-3">如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li class="lvl-3"><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li class="lvl-3">如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例">最简示例</h3><pre class="line-numbers language-language-yaml"><code class="language-language-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例">最全示例</h3><pre class="line-numbers language-language-yaml"><code class="language-language-yaml">---title: Nonedate: 2018-09-07 09:25:00author: 草泥马img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Front-matter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
